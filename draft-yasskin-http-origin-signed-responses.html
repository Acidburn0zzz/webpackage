<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Origin-signed HTTP Responses</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 525px);
    width: 300px;
    z-index: 1;
  }
  #rfc\.toc {
    top: 15px;
  }
  ul.toc, nav#rfc\.toc {
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>ul.toc {
    top: 80px;
  }

  body {
    padding-right: 350px;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 25px auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Terminology">
<link href="#rfc.section.3" rel="Chapter" title="3 Straw proposal">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 The Signed-Headers Header">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 The Signature Header">
<link href="#rfc.section.3.2.1" rel="Chapter" title="3.2.1 Open Questions">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Significant parts of an exchange">
<link href="#rfc.section.3.3.1" rel="Chapter" title="3.3.1 Open Questions">
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 CBOR representation of an exchange">
<link href="#rfc.section.3.4.1" rel="Chapter" title="3.4.1 Example">
<link href="#rfc.section.3.5" rel="Chapter" title="3.5 Canonical CBOR serialization">
<link href="#rfc.section.3.6" rel="Chapter" title="3.6 Signature validity">
<link href="#rfc.section.3.6.1" rel="Chapter" title="3.6.1 Open Questions">
<link href="#rfc.section.3.7" rel="Chapter" title="3.7 Updating signature validity">
<link href="#rfc.section.3.7.1" rel="Chapter" title="3.7.1 Examples">
<link href="#rfc.section.4" rel="Chapter" title="4 HTTP/2 extension for cross-origin Server Push">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Indicating support for cross-origin Server Push">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 NO_TRUSTED_EXCHANGE_SIGNATURE error code">
<link href="#rfc.section.4.2.1" rel="Chapter" title="4.2.1 Open Questions">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Validating a cross-origin Push">
<link href="#rfc.section.4.3.1" rel="Chapter" title="4.3.1 Validating a certificate chain for an authority">
<link href="#rfc.section.5" rel="Chapter" title="5 Security considerations">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Aspects of the straw proposal">
<link href="#rfc.section.6" rel="Chapter" title="6 Privacy considerations">
<link href="#rfc.section.7" rel="Chapter" title="7 IANA considerations">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Signature Header Field Registration">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 HTTP/2 Settings">
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 HTTP/2 Error code">
<link href="#rfc.references" rel="Chapter" title="8 References">
<link href="#rfc.references.1" rel="Chapter" title="8.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="8.2 Informative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Use cases">
<link href="#rfc.appendix.A.1" rel="Chapter" title="A.1 PUSHed subresources">
<link href="#rfc.appendix.A.2" rel="Chapter" title="A.2 Explicit use of a content distributor for subresources">
<link href="#rfc.appendix.A.3" rel="Chapter" title="A.3 Subresource Integrity">
<link href="#rfc.appendix.A.4" rel="Chapter" title="A.4 Offline websites">
<link href="#rfc.appendix.B" rel="Chapter" title="B Requirements">
<link href="#rfc.appendix.B.1" rel="Chapter" title="B.1 Proof of origin">
<link href="#rfc.appendix.B.1.1" rel="Chapter" title="B.1.1 Certificate constraints">
<link href="#rfc.appendix.B.1.2" rel="Chapter" title="B.1.2 Signature constraints">
<link href="#rfc.appendix.B.1.3" rel="Chapter" title="B.1.3 Retrieving the certificate">
<link href="#rfc.appendix.B.2" rel="Chapter" title="B.2 How much to sign">
<link href="#rfc.appendix.B.2.1" rel="Chapter" title="B.2.1 Conveying the signed headers">
<link href="#rfc.appendix.B.3" rel="Chapter" title="B.3 Response lifespan">
<link href="#rfc.appendix.B.3.1" rel="Chapter" title="B.3.1 Certificate revocation">
<link href="#rfc.appendix.B.3.2" rel="Chapter" title="B.3.2 Response downgrade attacks">
<link href="#rfc.appendix.C" rel="Chapter" title="C Determining validity using cache control">
<link href="#rfc.appendix.C.1" rel="Chapter" title="C.1 Example of updating cache control">
<link href="#rfc.appendix.C.2" rel="Chapter" title="C.2 Downsides of updating cache control">
<link href="#rfc.appendix.D" rel="Chapter" title="D Acknowledgements">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.8.4 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Yasskin, J." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-yasskin-http-origin-signed-responses-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2018-1-17" />
  <meta name="dct.abstract" content="This document explores how a server can send particular responses that are authoritative for an origin, when the server itself is not authoritative for that origin. For now, the appendices containing use cases and requirements should be treated as more confident than the proposal itself." />
  <meta name="description" content="This document explores how a server can send particular responses that are authoritative for an origin, when the server itself is not authoritative for that origin. For now, the appendices containing use cases and requirements should be treated as more confident than the proposal itself." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Network Working Group</td>
<td class="right">J. Yasskin</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Google</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">January 17, 2018</td>
</tr>
<tr>
<td class="left">Expires: July 21, 2018</td>
<td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Origin-signed HTTP Responses<br />
  <span class="filename">draft-yasskin-http-origin-signed-responses-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document explores how a server can send particular responses that are authoritative for an origin, when the server itself is not authoritative for that origin. For now, the appendices containing use cases and requirements should be treated as more confident than the proposal itself.</p>
<h1><a>Note to Readers</a></h1>
<p>Discussion of this draft takes place on the HTTP working group mailing list (ietf-http-wg@w3.org), which is archived at <a href="https://lists.w3.org/Archives/Public/ietf-http-wg/">https://lists.w3.org/Archives/Public/ietf-http-wg/</a>.</p>
<p>The source code and issues list for this draft can be found in <a href="https://github.com/WICG/webpackage">https://github.com/WICG/webpackage</a>.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on July 21, 2018.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2018 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Terminology</a>
</li>
<li>3.   <a href="#rfc.section.3">Straw proposal</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">The Signed-Headers Header</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">The Signature Header</a>
</li>
<ul><li>3.2.1.   <a href="#rfc.section.3.2.1">Open Questions</a>
</li>
</ul><li>3.3.   <a href="#rfc.section.3.3">Significant parts of an exchange</a>
</li>
<ul><li>3.3.1.   <a href="#rfc.section.3.3.1">Open Questions</a>
</li>
</ul><li>3.4.   <a href="#rfc.section.3.4">CBOR representation of an exchange</a>
</li>
<ul><li>3.4.1.   <a href="#rfc.section.3.4.1">Example</a>
</li>
</ul><li>3.5.   <a href="#rfc.section.3.5">Canonical CBOR serialization</a>
</li>
<li>3.6.   <a href="#rfc.section.3.6">Signature validity</a>
</li>
<ul><li>3.6.1.   <a href="#rfc.section.3.6.1">Open Questions</a>
</li>
</ul><li>3.7.   <a href="#rfc.section.3.7">Updating signature validity</a>
</li>
<ul><li>3.7.1.   <a href="#rfc.section.3.7.1">Examples</a>
</li>
</ul></ul><li>4.   <a href="#rfc.section.4">HTTP/2 extension for cross-origin Server Push</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Indicating support for cross-origin Server Push</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">NO_TRUSTED_EXCHANGE_SIGNATURE error code</a>
</li>
<ul><li>4.2.1.   <a href="#rfc.section.4.2.1">Open Questions</a>
</li>
</ul><li>4.3.   <a href="#rfc.section.4.3">Validating a cross-origin Push</a>
</li>
<ul><li>4.3.1.   <a href="#rfc.section.4.3.1">Validating a certificate chain for an authority</a>
</li>
</ul></ul><li>5.   <a href="#rfc.section.5">Security considerations</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Aspects of the straw proposal</a>
</li>
</ul><li>6.   <a href="#rfc.section.6">Privacy considerations</a>
</li>
<li>7.   <a href="#rfc.section.7">IANA considerations</a>
</li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Signature Header Field Registration</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">HTTP/2 Settings</a>
</li>
<li>7.3.   <a href="#rfc.section.7.3">HTTP/2 Error code</a>
</li>
</ul><li>8.   <a href="#rfc.references">References</a>
</li>
<ul><li>8.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>8.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Use cases</a>
</li>
<ul><li>A.1.   <a href="#rfc.appendix.A.1">PUSHed subresources</a>
</li>
<li>A.2.   <a href="#rfc.appendix.A.2">Explicit use of a content distributor for subresources</a>
</li>
<li>A.3.   <a href="#rfc.appendix.A.3">Subresource Integrity</a>
</li>
<li>A.4.   <a href="#rfc.appendix.A.4">Offline websites</a>
</li>
</ul><li>Appendix B.   <a href="#rfc.appendix.B">Requirements</a>
</li>
<ul><li>B.1.   <a href="#rfc.appendix.B.1">Proof of origin</a>
</li>
<ul><li>B.1.1.   <a href="#rfc.appendix.B.1.1">Certificate constraints</a>
</li>
<li>B.1.2.   <a href="#rfc.appendix.B.1.2">Signature constraints</a>
</li>
<li>B.1.3.   <a href="#rfc.appendix.B.1.3">Retrieving the certificate</a>
</li>
</ul><li>B.2.   <a href="#rfc.appendix.B.2">How much to sign</a>
</li>
<ul><li>B.2.1.   <a href="#rfc.appendix.B.2.1">Conveying the signed headers</a>
</li>
</ul><li>B.3.   <a href="#rfc.appendix.B.3">Response lifespan</a>
</li>
<ul><li>B.3.1.   <a href="#rfc.appendix.B.3.1">Certificate revocation</a>
</li>
<li>B.3.2.   <a href="#rfc.appendix.B.3.2">Response downgrade attacks</a>
</li>
</ul></ul><li>Appendix C.   <a href="#rfc.appendix.C">Determining validity using cache control</a>
</li>
<ul><li>C.1.   <a href="#rfc.appendix.C.1">Example of updating cache control</a>
</li>
<li>C.2.   <a href="#rfc.appendix.C.2">Downsides of updating cache control</a>
</li>
</ul><li>Appendix D.   <a href="#rfc.appendix.D">Acknowledgements</a>
</li>
<li><a href="#rfc.authors">Author's Address</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">When I <a href="https://datatracker.ietf.org/doc/minutes-99-dispatch/">presented Web Packaging to DISPATCH</a>, folks thought it would make sense to split it into a way to sign individual HTTP responses as coming from a particular origin, and separately a way to bundle a collection of HTTP responses. This document explores the constraints on any method of signing HTTP responses and sketches a possible solution to the constraints.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#terminology" id="terminology">Terminology</a>
</h1>
<p></p>

<dl>
<dt>Author</dt>
<dd style="margin-left: 8">The entity that controls the server for a particular origin <a href="#RFC6454" class="xref">[RFC6454]</a>. The author can get a CA to issue certificates for their private keys and can run a TLS server for their origin.</dd>
<dt>Exchange (noun)</dt>
<dd style="margin-left: 8">An HTTP request/response pair. This can either be a request from a client and the matching response from a server or the request in a PUSH_PROMISE and its matching response stream. Defined by Section 8 of <a href="#RFC7540" class="xref">[RFC7540]</a>.</dd>
<dt>Intermediate</dt>
<dd style="margin-left: 8">An entity that fetches signed HTTP exchanges from an author or another intermediate and forwards them to another intermediate or a client.</dd>
<dt>Client</dt>
<dd style="margin-left: 8">An entity that uses a signed HTTP exchange and needs to be able to prove that the author vouched for it as coming from its claimed origin.</dd>
<dt>Unix time</dt>
<dd style="margin-left: 8">Defined by <a href="#POSIX" class="xref">[POSIX]</a> <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_16">section 4.16</a>.</dd>
</dl>
<p id="rfc.section.2.p.2">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;NOT RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in BCP 14 <a href="#RFC2119" class="xref">[RFC2119]</a> <a href="#RFC8174" class="xref">[RFC8174]</a> when, and only when, they appear in all capitals, as shown here.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#proposal" id="proposal">Straw proposal</a>
</h1>
<p id="rfc.section.3.p.1">As a response to an HTTP request or as a Server Push (Section 8.2 of <a href="#RFC7540" class="xref">[RFC7540]</a>) the server MAY include a <samp>Signed-Headers</samp> header field (<a href="#signed-headers" class="xref">Section 3.1</a>) identifying <a href="#significant-parts" class="xref">significant</a> header fields and a <samp>Signature</samp> header field (<a href="#signature-header" class="xref">Section 3.2</a>) holding a list of one or more parameterised signatures that vouch for the content of the response.</p>
<p id="rfc.section.3.p.2">The client categorizes each signature as &#8220;valid&#8221; or &#8220;invalid&#8221; by validating that signature with its certificate or public key and other metadata against the significant headers and content (<a href="#signature-validity" class="xref">Section 3.6</a>). This validity then informs higher-level protocols.</p>
<p id="rfc.section.3.p.3">Each signature is parameterised with information to let a client fetch assurance that a signed exchange is still valid, in the face of revoked certificates and newly-discovered vulnerabilities. This assurance can be bundled back into the signed exchange and forwarded to another client, which won&#8217;t have to re-fetch this validity information for some period of time.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#signed-headers" id="signed-headers">The Signed-Headers Header</a>
</h1>
<p id="rfc.section.3.1.p.1">The <samp>Signed-Headers</samp> header field identifies an ordered list of response header fields to include in a signature. The request URL and response status are included unconditionally. This allows a TLS-terminating intermediate to reorder headers without breaking the signature. This <em>can</em> also allow the intermediate to add headers that will be ignored by some higher-level protocols, but <a href="#signature-validity" class="xref">Section 3.6</a> provides a hook to let other higher-level protocols reject such insecure headers.</p>
<p id="rfc.section.3.1.p.2">This header field appears once instead of being incorporated into the signatures&#8217; parameters because the significant header fields need to be consistent across all signatures of an exchange, to avoid forcing higher-level protocols to merge the header field lists of valid signatures.</p>
<p id="rfc.section.3.1.p.3">See <a href="#how-much-to-sign" class="xref">Appendix B.2</a> for a discussion of why only the URL from the request is included and not other request headers.</p>
<p><samp>Signed-Headers</samp> is a Structured Header as defined by <a href="#I-D.ietf-httpbis-header-structure" class="xref">[I-D.ietf-httpbis-header-structure]</a>. Its value MUST be a list (Section 4.8 of <a href="#I-D.ietf-httpbis-header-structure" class="xref">[I-D.ietf-httpbis-header-structure]</a>) of lowercase strings (Section 4.2 of <a href="#I-D.ietf-httpbis-header-structure" class="xref">[I-D.ietf-httpbis-header-structure]</a>) naming HTTP response header fields.  Pseudo-header field names (Section 8.1.2.1 of <a href="#RFC7540" class="xref">[RFC7540]</a>) MUST NOT appear in this list.</p>
<p id="rfc.section.3.1.p.5">Higher-level protocols SHOULD place requirements on the minimum set of headers to include in the <samp>Signed-Headers</samp> header field.</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#signature-header" id="signature-header">The Signature Header</a>
</h1>
<p id="rfc.section.3.2.p.1">The <samp>Signature</samp> header field conveys a list of signatures for an exchange, each one accompanied by information about how to determine the authority of and refresh that signature.</p>
<p id="rfc.section.3.2.p.2">The <samp>Signature</samp> header is a Structured Header as defined by <a href="#I-D.ietf-httpbis-header-structure" class="xref">[I-D.ietf-httpbis-header-structure]</a>. Its value MUST be a list (Section 4.8 of <a href="#I-D.ietf-httpbis-header-structure" class="xref">[I-D.ietf-httpbis-header-structure]</a>) of parameterised labels (Section 4.4 of <a href="#I-D.ietf-httpbis-header-structure" class="xref">[I-D.ietf-httpbis-header-structure]</a>).</p>
<p id="rfc.section.3.2.p.3">Each parameterised label MUST have parameters named &#8220;sig&#8221;, &#8220;validityUrl&#8221;, &#8220;date&#8221;, and &#8220;expires&#8221;, and either &#8220;certUrl&#8221; and &#8220;certSha256&#8221; parameters or an &#8220;ed25519Key&#8221; parameter. This specification gives no meaning to the label itself, which can be used as a human-readable identifier for the signature (see <a href="#parameterised-binary" class="xref">Section 3.2.1, Paragraph 1</a>). The present parameters MUST have the following values:</p>
<p></p>

<dl>
<dt>&#8220;sig&#8221;</dt>
<dd style="margin-left: 8">Binary content (Section 4.5 of <a href="#I-D.ietf-httpbis-header-structure" class="xref">[I-D.ietf-httpbis-header-structure]</a>) holding the signature of most of these parameters and the significant parts of the exchange (<a href="#significant-parts" class="xref">Section 3.3</a>).</dd>
<dt>&#8220;certUrl&#8221;</dt>
<dd style="margin-left: 8">A string (Section 4.2 of <a href="#I-D.ietf-httpbis-header-structure" class="xref">[I-D.ietf-httpbis-header-structure]</a>) containing a <a href="https://url.spec.whatwg.org/#valid-url-string">valid URL string</a>.</dd>
<dt>&#8220;certSha256&#8221;</dt>
<dd style="margin-left: 8">Binary content (Section 4.5 of <a href="#I-D.ietf-httpbis-header-structure" class="xref">[I-D.ietf-httpbis-header-structure]</a>) holding the SHA-256 hash of the first certificate found at &#8220;certUrl&#8221;.</dd>
<dt>&#8220;ed25519Key&#8221;</dt>
<dd style="margin-left: 8">Binary content (Section 4.5 of <a href="#I-D.ietf-httpbis-header-structure" class="xref">[I-D.ietf-httpbis-header-structure]</a>) holding an Ed25519 public key (<a href="#RFC8032" class="xref">[RFC8032]</a>).</dd>
<dt>&#8220;validityUrl&#8221;</dt>
<dd style="margin-left: 8">
<a name="signature-validityurl"></a>A string (Section 4.2 of <a href="#I-D.ietf-httpbis-header-structure" class="xref">[I-D.ietf-httpbis-header-structure]</a>) containing a <a href="https://url.spec.whatwg.org/#valid-url-string">valid URL string</a>.</dd>
<dt>&#8220;date&#8221; and &#8220;expires&#8221;</dt>
<dd style="margin-left: 8">An unsigned integer (Section 4.1 of <a href="#I-D.ietf-httpbis-header-structure" class="xref">[I-D.ietf-httpbis-header-structure]</a>) representing a Unix time.</dd>
</dl>
<p id="rfc.section.3.2.p.5">The &#8220;certUrl&#8221; and &#8220;validityUrl&#8221; parameters are <em>not</em> signed, so intermediates can update them with pointers to cached versions.</p>
<h1 id="rfc.section.3.2.1">
<a href="#rfc.section.3.2.1">3.2.1.</a> <a href="#open-questions" id="open-questions">Open Questions</a>
</h1>
<p><a href="#I-D.ietf-httpbis-header-structure" class="xref">[I-D.ietf-httpbis-header-structure]</a> provides a way to parameterise labels but not other supported types like binary content. If the <samp>Signature</samp> header field is notionally a list of parameterised signatures, maybe we should add a &#8220;parameterised binary content&#8221; type.</p>
<p id="rfc.section.3.2.1.p.2">Should the certUrl and validityUrl be lists so that intermediates can offer a cache without losing the original URLs? Putting lists in dictionary fields is more complex than <a href="#I-D.ietf-httpbis-header-structure" class="xref">[I-D.ietf-httpbis-header-structure]</a> allows, so they&#8217;re single items for now.</p>
<p id="rfc.section.3.2.1.p.3">Should &#8220;validityUrl&#8221; be signed or optionally signed so that an exchange&#8217;s author can prevent an intermediate from removing it, which would prevent clients from sharing the exchange among themselves without going back to the intermeidate?</p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#significant-parts" id="significant-parts">Significant parts of an exchange</a>
</h1>
<p id="rfc.section.3.3.p.1">The significant parts of an exchange are:</p>
<p></p>

<ul>
<li>The method (Section 4 of <a href="#RFC7231" class="xref">[RFC7231]</a>) and effective request URI (Section 5.5 of <a href="#RFC7230" class="xref">[RFC7230]</a>) of the request.</li>
<li>The response status code (Section 6 of <a href="#RFC7231" class="xref">[RFC7231]</a>) and the response header fields whose names are listed in that exchange&#8217;s <samp>Signed-Headers</samp> header field (<a href="#signed-headers" class="xref">Section 3.1</a>), in the order they appear in that header field. If a response header field name from <samp>Signed-Headers</samp> does not appear in the exchange&#8217;s response header fields, the exchange has no significant parts.</li>
<li>The exchange&#8217;s payload body (Section 3.3 of <a href="#RFC7230" class="xref">[RFC7230]</a>). Note that the payload body is the message body with any transfer encodings removed.</li>
</ul>
<p id="rfc.section.3.3.p.3">If the exchange&#8217;s <samp>Signed-Headers</samp> header field is not present, doesn&#8217;t parse as a Structured Header (<a href="#I-D.ietf-httpbis-header-structure" class="xref">[I-D.ietf-httpbis-header-structure]</a>) or doesn&#8217;t follow the constraints on its value described in <a href="#signed-headers" class="xref">Section 3.1</a>, the exchange has no significant parts.</p>
<h1 id="rfc.section.3.3.1">
<a href="#rfc.section.3.3.1">3.3.1.</a> <a href="#open-questions-1" id="open-questions-1">Open Questions</a>
</h1>
<p id="rfc.section.3.3.1.p.1">Do the significant parts of an exchange need to include the <samp>Signed-Headers</samp> header field itself?</p>
<h1 id="rfc.section.3.4">
<a href="#rfc.section.3.4">3.4.</a> <a href="#cbor-representation" id="cbor-representation">CBOR representation of an exchange</a>
</h1>
<p id="rfc.section.3.4.p.1">To sign an exchange, it needs to be serialized into a byte string. Since intermediaries and <a href="#uc-explicit-distributor" class="xref">distributors</a> might rearrange, add, or just reserialize headers, and this can change the HPACK encoding, we can&#8217;t use the literal bytes of the header frames as this serialization. Instead, this section defines a CBOR representation that can be embedded into other CBOR, canonically serialized (<a href="#canonical-cbor" class="xref">Section 3.5</a>), and then signed.</p>
<p id="rfc.section.3.4.p.2">The CBOR representation of an exchange is the result of the following algorithm:</p>
<p></p>

<ol>
<li>Let <samp>exchange</samp> be the exchange. This is expected to be the significant parts (<a href="#significant-parts" class="xref">Section 3.3</a>) of some other exchange.</li>
<li>Return a CBOR (<a href="#RFC7049" class="xref">[RFC7049]</a>) array with the following content: <ol>
<li>The text string &#8220;request&#8221;.</li>
<li>The array consisting of the following items: <ol>
<li>The byte string &#8216;:method&#8217;.</li>
<li>The byte string containing the request&#8217;s method.</li>
<li>The byte string &#8216;:url&#8217;.</li>
<li>The byte string containing the request&#8217;s effective request URI.</li>
</ol>
</li>
<li>The text string &#8220;response&#8221;.</li>
<li>The array consisting of the initial two items <ol>
<li>The byte string &#8216;:status&#8217;.</li>
<li>The byte string containing the response&#8217;s 3-digit status code.</li>
</ol>
<p> Followed by the appended items from, for each response header field in </p>
<samp>exchange</samp>, in order:      <ol>
<li>Append the header field&#8217;s name as a byte string.</li>
<li>Append the header field&#8217;s value as a byte string.</li>
</ol>
</li>
<li>The text string &#8220;payload&#8221;.</li>
<li>The byte string containing the response&#8217;s payload body (Section 3.3 of <a href="#RFC7230" class="xref">[RFC7230]</a>). Note that the payload body is the message body with any transfer encodings removed.</li>
</ol>
</li>
</ol>
<h1 id="rfc.section.3.4.1">
<a href="#rfc.section.3.4.1">3.4.1.</a> <a href="#example-cbor-representation" id="example-cbor-representation">Example</a>
</h1>
<p id="rfc.section.3.4.1.p.1">Given the HTTP exchange:</p>
<pre>
GET https://example.com/ HTTP/1.1
Accept: */*

HTTP/1.1 200
Content-Type: text/html
Signed-Headers: "content-type"

&lt;!doctype html&gt;
&lt;html&gt;
...
</pre>
<p id="rfc.section.3.4.1.p.2">The cbor representation consists of the following item, represented using the extended diagnostic notation from <a href="#I-D.ietf-cbor-cddl" class="xref">[I-D.ietf-cbor-cddl]</a> appendix G:</p>
<pre>
[
  "request",
  [
    ':method', 'GET',
    ':url', 'https://example.com/'
  ],
  "response",
  [
    ':status', '200',
    'content-type', 'text/html'
  ],
  "payload",
  '&lt;!doctype html&gt;\n&lt;html&gt;...'
]
</pre>
<h1 id="rfc.section.3.5">
<a href="#rfc.section.3.5">3.5.</a> <a href="#canonical-cbor" id="canonical-cbor">Canonical CBOR serialization</a>
</h1>
<p id="rfc.section.3.5.p.1">Within this specification, the canonical serialization of a CBOR item uses the following rules derived from Section 3.9 of <a href="#RFC7049" class="xref">[RFC7049]</a>:</p>
<p></p>

<ul>
<li>Integers and the lengths of arrays and strings MUST use the smallest possible encoding.</li>
<li>Items MUST NOT be encoded with indefinite length.</li>
</ul>
<p id="rfc.section.3.5.p.3">Note: this specification does not use CBOR maps, so the map ordering rules aren&#8217;t necessary. This specification also doesn&#8217;t use floating point, tags, or other more complex data types, so it doesn&#8217;t need rules to canonicalize those either.</p>
<h1 id="rfc.section.3.6">
<a href="#rfc.section.3.6">3.6.</a> <a href="#signature-validity" id="signature-validity">Signature validity</a>
</h1>
<p id="rfc.section.3.6.p.1">The client MUST parse the <samp>Signature</samp> header field as the list of parameterised values described in <a href="#signature-header" class="xref">Section 3.2</a> (Section 4.8.1 of <a href="#I-D.ietf-httpbis-header-structure" class="xref">[I-D.ietf-httpbis-header-structure]</a>). If an error is thrown during this parsing, the exchange has no valid signatures. Otherwise, each member of this list represents a signature with parameters.</p>
<p id="rfc.section.3.6.p.2">The client MUST use the following algorithm to determine whether each signature with parameters is invalid or potentially-valid. Potentially-valid results include:</p>
<p></p>

<ul>
<li>The signed parts of the exchange so that higher-level protocols can avoid relying on unsigned headers, and</li>
<li>Either a certificate chain or a public key so that a higher-level protocol can determine whether it&#8217;s actually valid.</li>
</ul>
<p id="rfc.section.3.6.p.4"><a name="force-fetch"></a>This algorithm accepts a <samp>forceFetch</samp> flag that avoids the cache when fetching URLs. A client that determines that a potentially-valid certificate chain is actually invalid due to an expired OCSP response MAY retry with <samp>forceFetch</samp> set to retrieve an updated OCSP from the original server.</p>
<p id="rfc.section.3.6.p.5">This algorithm also accepts an <samp>allResponseHeaders</samp> flag, which insists that there are no non-significant response header fields in the exchange.</p>
<p></p>

<ol>
<li>Let <samp>originalExchange</samp> be the signature&#8217;s exchange.</li>
<li>Let <samp>exchange</samp> be the significant parts (<a href="#significant-parts" class="xref">Section 3.3</a>) of <samp>originalExchange</samp>. If <samp>originalExchange</samp> has no significant parts, then return &#8220;invalid&#8221;.</li>
<li>If <samp>allResponseHeaders</samp> is set and the response headers fields in <samp>originalExchange</samp> are a proper superset of the response header fields in <samp>exchange</samp>, then return &#8220;invalid&#8221;.</li>
<li>Let: <ul>
<li>
<samp>signature</samp> be the signature (binary content in the parameterised value&#8217;s &#8220;sig&#8221; parameter).</li>
<li>
<samp>certUrl</samp> be the signature&#8217;s &#8220;certUrl&#8221; parameter, if any.</li>
<li>
<samp>certSha256</samp> be the signature&#8217;s &#8220;certSha256&#8221; parameter, if any.</li>
<li>
<samp>ed25519Key</samp> be the signature&#8217;s &#8220;ed25519Key&#8221; parameter, if any.</li>
<li>
<samp>date</samp> be the signature&#8217;s &#8220;date&#8221; parameter, interpreted as a Unix time.</li>
<li>
<samp>expires</samp> be the signature&#8217;s &#8220;expires&#8221; parameter, interpreted as a Unix time.</li>
</ul>
</li>
<li>Set <samp>publicKey</samp> and <samp>signing-alg</samp> depending on which key fields are present: <ol>
<li>If <samp>certUrl</samp> is present: <ol>
<li>Let <samp>certificate-chain</samp> be the result of fetching (<a href="#FETCH" class="xref">[FETCH]</a>) <samp>certUrl</samp> and parsing it as a TLS 1.3 Certificate message (Section 4.4.2 of <a href="#I-D.ietf-tls-tls13" class="xref">[I-D.ietf-tls-tls13]</a>) containing X.509v3 certificates. If <samp>forceFetch</samp> is <em>not</em> set, the fetch can be fulfilled from a cache using normal HTTP semantics <a href="#RFC7234" class="xref">[RFC7234]</a>. If this fetch or parse fails, return &#8220;invalid&#8221;.          <br><br> Parsing notes: 1. This does not include the 4-byte header that would appear in a Handshake message.  1. Since this fetch is not in response to a CertificateRequest, the certificate_request_context MUST be empty, and a non-empty value MUST cause the parse to fail.</li>
<li>Let <samp>main-certificate</samp> be the first certificate in <samp>certificate-chain</samp>.</li>
<li>If the SHA-256 hash of <samp>main-certificate</samp>&#8217;s <samp>cert_data</samp> is not equal to <samp>certSha256</samp>, return &#8220;invalid&#8221;. Note that this intentionally differs from TLS 1.3, which signs the entire certificate chain in its Certificate Verify (Section 4.4.3 of <a href="#I-D.ietf-tls-tls13" class="xref">[I-D.ietf-tls-tls13]</a>), in order to allow updating the stapled OCSP response without updating signatures at the same time.</li>
<li>Set <samp>publicKey</samp> to <samp>main-certificate</samp>&#8217;s public key</li>
<li>The client MUST define a partial function from public key types to signing algorithms, and this function must at the minimum include the following mappings:          <dl>
<dt>RSA, 2048 bits:</dt>
<dd style="margin-left: 8">rsa_pss_sha256 as defined in Section 4.2.3 of <a href="#I-D.ietf-tls-tls13" class="xref">[I-D.ietf-tls-tls13]</a>.</dd>
<dt>EC, with the secp256r1 curve:</dt>
<dd style="margin-left: 8">ecdsa_secp256r1_sha256 as defined in Section 4.2.3 of <a href="#I-D.ietf-tls-tls13" class="xref">[I-D.ietf-tls-tls13]</a>.</dd>
<dt>EC, with the secp384r1 curve:</dt>
<dd style="margin-left: 8">ecdsa_secp384r1_sha384 as defined in Section 4.2.3 of <a href="#I-D.ietf-tls-tls13" class="xref">[I-D.ietf-tls-tls13]</a>.</dd>
</dl>
<p> Set </p>
<samp>signing-alg</samp> to the result of applying this function to type of <samp>main-certificate</samp>&#8217;s public key. If the function is undefined on this input, return &#8220;invalid&#8221;.</li>
</ol>
</li>
<li>If <samp>ed25519Key</samp> is present, set <samp>publicKey</samp> to <samp>ed25519Key</samp> and <samp>signing-alg</samp> to ed25519, as defined by <a href="#RFC8032" class="xref">[RFC8032]</a>
</li>
</ol>
</li>
<li>If <samp>expires</samp> is more than 7 days (604800 seconds) after <samp>date</samp>, return &#8220;invalid&#8221;.</li>
<li>If the current time is before <samp>date</samp> or after <samp>expires</samp>, return &#8220;invalid&#8221;.</li>
<li>Let <samp>message</samp> be the concatenation of the following byte strings. This matches the <a href="#I-D.ietf-tls-tls13" class="xref">[I-D.ietf-tls-tls13]</a> format to avoid cross-protocol attacks when TLS certificates are used to sign manifests.  <ol>
<li>A string that consists of octet 32 (0x20) repeated 64 times.</li>
<li>A context string: the ASCII encoding of &#8220;HTTP Exchange&#8221;.</li>
<li>A single 0 byte which serves as a separator.</li>
<li>The bytes of the canonical CBOR serialization (<a href="#canonical-cbor" class="xref">Section 3.5</a>) of a CBOR array consisting of: <ol>
<li>If <samp>certSha256</samp> is set: <ol>
<li>The text string &#8220;certSha256&#8221;.</li>
<li>The byte string <samp>certSha256</samp>.</li>
</ol>
</li>
<li>The text string &#8220;date&#8221;.</li>
<li>The integer value of <samp>date</samp>.</li>
<li>The text string &#8220;expires&#8221;.</li>
<li>The integer value of <samp>expires</samp>.</li>
<li>The text string &#8220;exchange&#8221;.</li>
<li>The CBOR representation (<a href="#cbor-representation" class="xref">Section 3.4</a>) of <samp>exchange</samp>. See the <a href="#incremental-validity" class="xref">open questions</a>.</li>
</ol>
</li>
</ol>
</li>
<li>If <samp>signature</samp> is <samp>message</samp>&#8217;s signature by <samp>main-certificate</samp>&#8217;s public key using <samp>signing-alg</samp>, return &#8220;potentially-valid&#8221; with <samp>exchange</samp> and whichever is present of <samp>certificate-chain</samp> or <samp>ed25519Key</samp>. Otherwise, return &#8220;invalid&#8221;.</li>
</ol>
<h1 id="rfc.section.3.6.1">
<a href="#rfc.section.3.6.1">3.6.1.</a> <a href="#open-questions-2" id="open-questions-2">Open Questions</a>
</h1>
<p id="rfc.section.3.6.1.p.1"><a name="incremental-validity"></a>Including the entire exchange in the signed data forces a client to download the whole thing before trusting any of it. <a href="#I-D.thomson-http-mice" class="xref">[I-D.thomson-http-mice]</a> is designed to let us check the validity of just the <samp>MI</samp> header up front and then incrementally check blocks of the payload as they arrive. What&#8217;s the best way to integrate that? Maybe add a flag to the <samp>Signature</samp> header field or its signatures saying that the payload is guarded by some other header field, so isn&#8217;t included in the significant parts (<a href="#significant-parts" class="xref">Section 3.3</a>).</p>
<h1 id="rfc.section.3.7">
<a href="#rfc.section.3.7">3.7.</a> <a href="#updating-validity" id="updating-validity">Updating signature validity</a>
</h1>
<p id="rfc.section.3.7.p.1">Both OCSP responses and signatures are designed to expire a short time after they&#8217;re signed, so that revoked certificates and signed exchanges with known vulnerabilities are distrusted promptly.</p>
<p id="rfc.section.3.7.p.2">This specification provides no way to update OCSP responses by themselves.  Instead, <a href="#force-fetch" class="xref">clients need to re-fetch the &#8220;certUrl&#8221;</a> to get a chain including a newer OCSP response.</p>
<p id="rfc.section.3.7.p.3">The <a href="#signature-validityurl" class="xref">&#8220;validityUrl&#8221; parameter</a> of the signatures provides a way to fetch new signatures or learn where to fetch a complete updated package.</p>
<p id="rfc.section.3.7.p.4">Each version of a signed exchange SHOULD have its own validity URLs, since each version needs different signatures and becomes obsolete at different times.</p>
<p id="rfc.section.3.7.p.5">The resource at a &#8220;validityUrl&#8221; is &#8220;validity data&#8221;, a CBOR map matching the following CDDL (<a href="#I-D.ietf-cbor-cddl" class="xref">[I-D.ietf-cbor-cddl]</a>):</p>
<pre>
validity = {
  ? signatures: [ + bytes ]
  ? update: {
    url: text,
    ? size: uint,
  }
]
</pre>
<p id="rfc.section.3.7.p.6">The elements of the <samp>signatures</samp> array are header field values meant to replace the signatures within the <samp>Signature</samp> header field pointing to this validity data. If the signed exchange contains a bug severe enough that clients need to stop using the content, the <samp>signatures</samp> array MUST NOT be present.</p>
<p id="rfc.section.3.7.p.7">The <samp>update</samp> map gives a location to update the entire signed exchange and an estimate of the size of the resource at that URL. If the signed exchange is currently the most recent version, the <samp>update</samp> SHOULD NOT be present.</p>
<p id="rfc.section.3.7.p.8">If both the <samp>signatures</samp> and <samp>update</samp> fields are present, clients can use the estimated size to decide whether to update the whole resource or just its signatures.</p>
<h1 id="rfc.section.3.7.1">
<a href="#rfc.section.3.7.1">3.7.1.</a> <a href="#examples-updating-validity" id="examples-updating-validity">Examples</a>
</h1>
<p id="rfc.section.3.7.1.p.1">For example, if a signed exchange has the following <samp>Signature</samp> header field (written as multiple fields for convenience):</p>
<pre>
Signature: sig1;
  sig=*MEUCIQDXlI2gN3RNBlgFiuRNFpZXcDIaUpX6HIEwcZEc0cZYLAIga9DsVOMM+g5YpwEBdGW3sS+bvnmAJJiSMwhuBdqp5UY;
  validityUrl="https://example.com/resource.validity";
  certUrl="https://example.com/certs";
  certSha256=*W7uB969dFW3Mb5ZefPS9Tq5ZbH5iSmOILpjv2qEArmI;
  date=1511128380; expires=1511560380
Signature: sig2;
  sig=*MEQCIGjZRqTRf9iKNkGFyzRMTFgwf/BrY2ZNIP/dykhUV0aYAiBTXg+8wujoT4n/W+cNgb7pGqQvIUGYZ8u8HZJ5YH26Qg;
  validityUrl="https://example.com/resource.validity";
  certUrl="https://example.com/certs";
  certSha256=*kQAA8u33cZRTy7RHMO4+dv57baZL48SYA2PqmYvPPbg;
  date=1511301183; expires=1511905983
Signature: sig3;
  sig=*MEYCIQCNxJzn6Rh2fNxsobktir8TkiaJYQFhWTuWI1i4PewQaQIhAMs2TVjc4rTshDtXbgQEOwgj2mRXALhfXPztXgPupii+;
  validityUrl="https://thirdparty.example.com/resource.validity";
  certUrl="https://thirdparty.example.com/certs";
  certSha256=*UeOwUPkvxlGRTyvHcsMUN0A2oNsZbU8EUvg8A9ZAnNc;
  date=1511301183; expires=1511905983
</pre>
<p id="rfc.section.3.7.1.p.2">https://example.com/resource.validity might contain:</p>
<pre>
{
  "signatures": [
    'sig4; '
    'sig=*MEQCIC/I9Q+7BZFP6cSDsWx43pBAL0ujTbON/+7RwKVk+ba5AiB3FSFLZqpzmDJ0NumNwN04pqgJZE99fcK86UjkPbj4jw; '
    'validityUrl="https://example.com/resource.validity"; '
    'certUrl="https://example.com/certs"; '
    'certSha256=*W7uB969dFW3Mb5ZefPS9Tq5ZbH5iSmOILpjv2qEArmI; '
    'date=1511467200; expires=1511985600'
  ],
  "update": {
    "url": "https://example.com/resource",
    "size": 5557452
  }
}
</pre>
<p id="rfc.section.3.7.1.p.3">This indicates that the first two of the original signatures (the ones with a validityUrl of &#8220;https://example.com/resource.validity&#8221;) can be replaced with a single new signature. The signatures of the updated signed exchange would be:</p>
<pre>
Signature: sig4;
  sig=*MEQCIC/I9Q+7BZFP6cSDsWx43pBAL0ujTbON/+7RwKVk+ba5AiB3FSFLZqpzmDJ0NumNwN04pqgJZE99fcK86UjkPbj4jw;
  validityUrl="https://example.com/resource.validity";
  certUrl="https://example.com/certs";
  certSha256=*W7uB969dFW3Mb5ZefPS9Tq5ZbH5iSmOILpjv2qEArmI;
  date=1511467200; expires=1511985600
Signature: sig3;
  sig=*MEYCIQCNxJzn6Rh2fNxsobktir8TkiaJYQFhWTuWI1i4PewQaQIhAMs2TVjc4rTshDtXbgQEOwgj2mRXALhfXPztXgPupii+;
  validityUrl="https://thirdparty.example.com/resource.validity";
  certUrl="https://thirdparty.example.com/certs";
  certSha256=*UeOwUPkvxlGRTyvHcsMUN0A2oNsZbU8EUvg8A9ZAnNc;
  date=1511301183; expires=1511905983
</pre>
<p id="rfc.section.3.7.1.p.4">https://example.com/resource.validity could also expand the set of signatures if its <samp>signatures</samp> array contained more than 2 elements.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#cross-origin-push" id="cross-origin-push">HTTP/2 extension for cross-origin Server Push</a>
</h1>
<p id="rfc.section.4.p.1">To allow servers to Server-Push (Section 8.2 of <a href="#RFC7540" class="xref">[RFC7540]</a>) signed exchanges (<a href="#proposal" class="xref">Section 3</a>) signed by an authority for which the server is not authoritative (Section 9.1 of <a href="#RFC7230" class="xref">[RFC7230]</a>), this section defines an HTTP/2 extension.</p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#setting" id="setting">Indicating support for cross-origin Server Push</a>
</h1>
<p id="rfc.section.4.1.p.1">Clients that might accept signed Server Pushes with an authority for which the server is not authoritative indicate this using the HTTP/2 SETTINGS parameter ENABLE_CROSS_ORIGIN_PUSH (0xSETTING-TBD).</p>
<p id="rfc.section.4.1.p.2">An ENABLE_CROSS_ORIGIN_PUSH value of 0 indicates that the client does not support cross-origin Push. A value of 1 indicates that the client does support cross-origin Push.</p>
<p id="rfc.section.4.1.p.3">A client MUST NOT send a ENABLE_CROSS_ORIGIN_PUSH setting with a value other than 0 or 1 or a value of 0 after previously sending a value of 1. If a server receives a value that violates these rules, it MUST treat it as a connection error (Section 5.4.1 of <a href="#RFC7540" class="xref">[RFC7540]</a>) of type PROTOCOL_ERROR.</p>
<p id="rfc.section.4.1.p.4">The use of a SETTINGS parameter to opt-in to an otherwise incompatible protocol change is a use of &#8220;Extending HTTP/2&#8221; defined by Section 5.5 of <a href="#RFC7540" class="xref">[RFC7540]</a>. If a server were to send a cross-origin Push without first receiving a ENABLE_CROSS_ORIGIN_PUSH setting with the value of 1 it would be a protocol violation.</p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#error-code" id="error-code">NO_TRUSTED_EXCHANGE_SIGNATURE error code</a>
</h1>
<p id="rfc.section.4.2.p.1">The signatures on a Pushed cross-origin exchange may be untrusted for several reasons, for example that the certificate could not be fetched, that the certificate does not chain to a trusted root, that the signature itself doesn&#8217;t validate, that the signature is expired, etc. This draft conflates all of these possible failures into one error code, NO_TRUSTED_EXCHANGE_SIGNATURE (0xERROR-TBD).</p>
<h1 id="rfc.section.4.2.1">
<a href="#rfc.section.4.2.1">4.2.1.</a> <a href="#open-questions-3" id="open-questions-3">Open Questions</a>
</h1>
<p id="rfc.section.4.2.1.p.1">How fine-grained should this specification&#8217;s error codes be?</p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> <a href="#validating-cross-origin-push" id="validating-cross-origin-push">Validating a cross-origin Push</a>
</h1>
<p id="rfc.section.4.3.p.1">If the client has set the ENABLE_CROSS_ORIGIN_PUSH setting to 1, the server MAY Push a signed exchange for which it is not authoritative, and the client MUST NOT treat a PUSH_PROMISE for which the server is not authoritative as a stream error (Section 5.4.2 of <a href="#RFC7540" class="xref">[RFC7540]</a>) of type PROTOCOL_ERROR, as described in Section 8.2 of <a href="#RFC7540" class="xref">[RFC7540]</a>.</p>
<p id="rfc.section.4.3.p.2">Instead, the client MUST validate such a PUSH_PROMISE and its response by parsing the <samp>Signature</samp> header into a list of signatures according to the instructions in <a href="#signature-validity" class="xref">Section 3.6</a>, and searching that list for a valid signature using the algorithm in <a href="#authority-chain-validation" class="xref">Section 4.3.1</a>. If no valid signature is found, the client MUST treat the response as a stream error (Section 5.4.2 of <a href="#RFC7540" class="xref">[RFC7540]</a>) of type NO_TRUSTED_EXCHANGE_SIGNATURE.  Otherwise, the client MUST treat the pushed response as if the server were authoritative for the PUSH_PROMISE&#8217;s authority.</p>
<h1 id="rfc.section.4.3.1">
<a href="#rfc.section.4.3.1">4.3.1.</a> <a href="#authority-chain-validation" id="authority-chain-validation">Validating a certificate chain for an authority</a>
</h1>
<p></p>

<ol>
<li>Run <a href="#signature-validity" class="xref">Section 3.6</a> over the signature with the <samp>allResponseHeaders</samp> flag set, getting <samp>exchange</samp> and <samp>certificate-chain</samp> back. If this returned &#8220;invalid&#8221; or didn&#8217;t return a certificate chain, return &#8220;invalid&#8221;.</li>
<li>Let <samp>authority</samp> be the host component of <samp>exchange</samp>&#8217;s effective request URI.</li>
<li>Validate the <samp>certificate-chain</samp> using the following substeps. If any of them fail, re-run <a href="#signature-validity" class="xref">Section 3.6</a> once over the signature with both the <samp>forceFetch</samp> flag and the <samp>allResponseHeaders</samp> flag set, and restart from step 2. If a substep fails again, return &#8220;invalid&#8221;.  <ol>
<li>Use <samp>certificate-chain</samp> to validate that its first entry, <samp>main-certificate</samp> is trusted as <samp>authority</samp>&#8217;s server certificate (<a href="#RFC5280" class="xref">[RFC5280]</a> and other undocumented conventions). Let <samp>path</samp> be the path that was used from the <samp>main-certificate</samp> to a trusted root, including the <samp>main-certificate</samp> but excluding the root.</li>
<li>Validate that <samp>main-certificate</samp> includes a &#8220;status_request&#8221; extension with a valid OCSP response whose lifetime (<samp>nextUpdate - thisUpdate</samp>) is less than 7 days (<a href="#RFC6960" class="xref">[RFC6960]</a>). Note that this does not check for revocation of intermediate certificates, and clients SHOULD implement another mechanism for that.</li>
<li>Validate that all certificates in <samp>path</samp> include &#8220;signed_certificate_timestamp&#8221; extensions containing valid SCTs from trusted logs. (<a href="#RFC6962" class="xref">[RFC6962]</a>)</li>
</ol>
</li>
<li>Return &#8220;valid&#8221;.</li>
</ol>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#security-considerations" id="security-considerations">Security considerations</a>
</h1>
<p id="rfc.section.5.p.1">Authors MUST NOT include confidential information in a signed response that an untrusted intermediate could forward, since the response is only signed and not encrypted. Intermediates can read the content.</p>
<p id="rfc.section.5.p.2">Relaxing the requirement to consult DNS when determining authority for an origin means that an attacker who possesses a valid certificate no longer needs to be on-path to redirect traffic to them; instead of modifying DNS, they need only convince the user to visit another Web site in order to serve responses signed as the target. This consideration and mitigations for it are shared by <a href="#I-D.ietf-httpbis-origin-frame" class="xref">[I-D.ietf-httpbis-origin-frame]</a>.</p>
<p id="rfc.section.5.p.3">Signing a bad response can affect more users than simply serving a bad response, since a served response will only affect users who make a request while the bad version is live, while an attacker can forward a signed response until its signature expires. Authors should consider shorter signature expiration times than they use for cache expiration times.</p>
<p id="rfc.section.5.p.4">An attacker with temporary access to a signing oracle can sign &#8220;still valid&#8221; assertions with arbitrary timestamps and expiration times. As a result, when a signing oracle is removed, the keys it provided access to SHOULD be revoked so that, even if the attacker used them to sign future-dated package validity assertions, the key&#8217;s OCSP assertion will expire, causing the package as a whole to become untrusted.</p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#aspects-of-the-straw-proposal" id="aspects-of-the-straw-proposal">Aspects of the straw proposal</a>
</h1>
<p id="rfc.section.5.1.p.1">The use of a single <samp>Signed-Headers</samp> header field prevents us from signing aspects of the request other than its effective request URI (Section 5.5 of <a href="#RFC7230" class="xref">[RFC7230]</a>). For example, if an author signs both <samp>Content-Encoding: br</samp> and <samp>Content-Encoding: gzip</samp> variants of a response, what&#8217;s the impact if an attacker serves the brotli one for a request with <samp>Accept-Encoding: gzip</samp>?</p>
<p id="rfc.section.5.1.p.2">The simple form of <samp>Signed-Headers</samp> also prevents us from signing less than the full request URL. The SRI use case (<a href="#uc-sri" class="xref">Appendix A.3</a>) may benefit from being able to leave the authority less constrained.</p>
<p><a href="#signature-validity" class="xref">Section 3.6</a> can succeed when some delivered headers aren&#8217;t included in the signed set. This accommodates current TLS-terminating intermediates and may be useful for SRI (<a href="#uc-sri" class="xref">Appendix A.3</a>), but is risky for trusting cross-origin responses (<a href="#uc-pushed-subresources" class="xref">Appendix A.1</a>, <a href="#uc-explicit-distributor" class="xref">Appendix A.2</a>, and <a href="#uc-offline-websites" class="xref">Appendix A.4</a>). <a href="#cross-origin-push" class="xref">Section 4</a> requires all headers to be included in the signature before trusting cross-origin pushed resources, at Ryan Sleevi&#8217;s recommendation.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#privacy-considerations" id="privacy-considerations">Privacy considerations</a>
</h1>
<p id="rfc.section.6.p.1">Normally, when a client fetches <samp>https://o1.com/resource.js</samp>, <samp>o1.com</samp> learns that the client is interested in the resource. If <samp>o1.com</samp> signs <samp>resource.js</samp>, <samp>o2.com</samp> serves it as <samp>https://o2.com/o1resource.js</samp>, and the client fetches it from there, then <samp>o2.com</samp> learns that the client is interested, and if the client executes the Javascript, that could also report the client&#8217;s interest back to <samp>o1.com</samp>.</p>
<p id="rfc.section.6.p.2">Often, <samp>o2.com</samp> already knew about the client&#8217;s interest, because it&#8217;s the entity that directed the client to <samp>o1resource.js</samp>, but there may be cases where this leaks extra information.</p>
<p id="rfc.section.6.p.3">For non-executable resource types, a signed response can improve the privacy situation by hiding the client&#8217;s interest from the original author.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#iana-considerations" id="iana-considerations">IANA considerations</a>
</h1>
<p id="rfc.section.7.p.1">TODO: possibly register the validityUrl format.</p>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> <a href="#signature-header-field-registration" id="signature-header-field-registration">Signature Header Field Registration</a>
</h1>
<p id="rfc.section.7.1.p.1">This section registers the <samp>Signature</samp> header field in the &#8220;Permanent Message Header Field Names&#8221; registry (<a href="#RFC3864" class="xref">[RFC3864]</a>).</p>
<p id="rfc.section.7.1.p.2">Header field name:  <samp>Signature</samp></p>
<p id="rfc.section.7.1.p.3">Applicable protocol:  http</p>
<p id="rfc.section.7.1.p.4">Status:  standard</p>
<p id="rfc.section.7.1.p.5">Author/Change controller:  IETF</p>
<p id="rfc.section.7.1.p.6">Specification document(s):  <a href="#signature-header" class="xref">Section 3.2</a> of this document</p>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> <a href="#http2-settings" id="http2-settings">HTTP/2 Settings</a>
</h1>
<p id="rfc.section.7.2.p.1">This section establishes an entry for the HTTP/2 Settings Registry that was established by Section 11.3 of <a href="#RFC7540" class="xref">[RFC7540]</a></p>
<p id="rfc.section.7.2.p.2">Name: ENABLE_CROSS_ORIGIN_PUSH</p>
<p id="rfc.section.7.2.p.3">Code: 0xSETTING-TBD</p>
<p id="rfc.section.7.2.p.4">Initial Value: 0</p>
<p id="rfc.section.7.2.p.5">Specification: This document</p>
<h1 id="rfc.section.7.3">
<a href="#rfc.section.7.3">7.3.</a> <a href="#http2-error-code" id="http2-error-code">HTTP/2 Error code</a>
</h1>
<p id="rfc.section.7.3.p.1">This section establishes an entry for the HTTP/2 Error Code Registry that was established by Section 11.4 of <a href="#RFC7540" class="xref">[RFC7540]</a></p>
<p id="rfc.section.7.3.p.2">Name: NO_TRUSTED_EXCHANGE_SIGNATURE</p>
<p id="rfc.section.7.3.p.3">Code: 0xERROR-TBD</p>
<p id="rfc.section.7.3.p.4">Description: The client does not trust the signature for a cross-origin Pushed signed exchange.</p>
<p id="rfc.section.7.3.p.5">Specification: This document</p>
<h1 id="rfc.references">
<a href="#rfc.references">8.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">8.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="FETCH">[FETCH]</b></td>
<td class="top">
<a>WHATWG</a>, "<a href="https://fetch.spec.whatwg.org/">Fetch</a>", January 2018.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-cbor-cddl">[I-D.ietf-cbor-cddl]</b></td>
<td class="top">
<a>Birkholz, H.</a>, <a>Vigano, C.</a> and <a>C. Bormann</a>, "<a href="https://tools.ietf.org/html/draft-ietf-cbor-cddl-00">Concise data definition language (CDDL): a notational convention to express CBOR data structures</a>", Internet-Draft draft-ietf-cbor-cddl-00, July 2017.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-httpbis-header-structure">[I-D.ietf-httpbis-header-structure]</b></td>
<td class="top">
<a>Nottingham, M.</a> and <a>P. Kamp</a>, "<a href="https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-02">Structured Headers for HTTP</a>", Internet-Draft draft-ietf-httpbis-header-structure-02, November 2017.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</b></td>
<td class="top">
<a>Rescorla, E.</a>, "<a href="https://tools.ietf.org/html/draft-ietf-tls-tls13-23">The Transport Layer Security (TLS) Protocol Version 1.3</a>", Internet-Draft draft-ietf-tls-tls13-23, January 2018.</td>
</tr>
<tr>
<td class="reference"><b id="POSIX">[POSIX]</b></td>
<td class="top">
<a>IEEE</a> and <a>The Open Group</a>, "<a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/">The Open Group Base Specifications Issue 7</a>", name IEEE, value 1003.1-2008, 2016 Edition, 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3864">[RFC3864]</b></td>
<td class="top">
<a>Klyne, G.</a>, <a>Nottingham, M.</a> and <a>J. Mogul</a>, "<a href="https://tools.ietf.org/html/rfc3864">Registration Procedures for Message Header Fields</a>", BCP 90, RFC 3864, DOI 10.17487/RFC3864, September 2004.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5280">[RFC5280]</b></td>
<td class="top">
<a>Cooper, D.</a>, <a>Santesson, S.</a>, <a>Farrell, S.</a>, <a>Boeyen, S.</a>, <a>Housley, R.</a> and <a>W. Polk</a>, "<a href="https://tools.ietf.org/html/rfc5280">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a>", RFC 5280, DOI 10.17487/RFC5280, May 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6960">[RFC6960]</b></td>
<td class="top">
<a>Santesson, S.</a>, <a>Myers, M.</a>, <a>Ankney, R.</a>, <a>Malpani, A.</a>, <a>Galperin, S.</a> and <a>C. Adams</a>, "<a href="https://tools.ietf.org/html/rfc6960">X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP</a>", RFC 6960, DOI 10.17487/RFC6960, June 2013.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6962">[RFC6962]</b></td>
<td class="top">
<a>Laurie, B.</a>, <a>Langley, A.</a> and <a>E. Kasper</a>, "<a href="https://tools.ietf.org/html/rfc6962">Certificate Transparency</a>", RFC 6962, DOI 10.17487/RFC6962, June 2013.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7049">[RFC7049]</b></td>
<td class="top">
<a>Bormann, C.</a> and <a>P. Hoffman</a>, "<a href="https://tools.ietf.org/html/rfc7049">Concise Binary Object Representation (CBOR)</a>", RFC 7049, DOI 10.17487/RFC7049, October 2013.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7230">[RFC7230]</b></td>
<td class="top">
<a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="https://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>", RFC 7230, DOI 10.17487/RFC7230, June 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7231">[RFC7231]</b></td>
<td class="top">
<a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="https://tools.ietf.org/html/rfc7231">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>", RFC 7231, DOI 10.17487/RFC7231, June 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7234">[RFC7234]</b></td>
<td class="top">
<a>Fielding, R.</a>, <a>Nottingham, M.</a> and <a>J. Reschke</a>, "<a href="https://tools.ietf.org/html/rfc7234">Hypertext Transfer Protocol (HTTP/1.1): Caching</a>", RFC 7234, DOI 10.17487/RFC7234, June 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7540">[RFC7540]</b></td>
<td class="top">
<a>Belshe, M.</a>, <a>Peon, R.</a> and <a>M. Thomson</a>, "<a href="https://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>", RFC 7540, DOI 10.17487/RFC7540, May 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8032">[RFC8032]</b></td>
<td class="top">
<a>Josefsson, S.</a> and <a>I. Liusvaara</a>, "<a href="https://tools.ietf.org/html/rfc8032">Edwards-Curve Digital Signature Algorithm (EdDSA)</a>", RFC 8032, DOI 10.17487/RFC8032, January 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8174">[RFC8174]</b></td>
<td class="top">
<a>Leiba, B.</a>, "<a href="https://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">8.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.burke-content-signature">[I-D.burke-content-signature]</b></td>
<td class="top">
<a>Burke, B.</a>, "<a href="https://tools.ietf.org/html/draft-burke-content-signature-00">HTTP Header for digital signatures</a>", Internet-Draft draft-burke-content-signature-00, March 2011.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.cavage-http-signatures">[I-D.cavage-http-signatures]</b></td>
<td class="top">
<a>Cavage, M.</a> and <a>M. Sporny</a>, "<a href="https://tools.ietf.org/html/draft-cavage-http-signatures-09">Signing HTTP Messages</a>", Internet-Draft draft-cavage-http-signatures-09, November 2017.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-httpbis-origin-frame">[I-D.ietf-httpbis-origin-frame]</b></td>
<td class="top">
<a>Nottingham, M.</a> and <a>E. Nygren</a>, "<a href="https://tools.ietf.org/html/draft-ietf-httpbis-origin-frame-06">The ORIGIN HTTP/2 Frame</a>", Internet-Draft draft-ietf-httpbis-origin-frame-06, January 2018.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.thomson-http-content-signature">[I-D.thomson-http-content-signature]</b></td>
<td class="top">
<a>Thomson, M.</a>, "<a href="https://tools.ietf.org/html/draft-thomson-http-content-signature-00">Content-Signature Header Field for HTTP</a>", Internet-Draft draft-thomson-http-content-signature-00, July 2015.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.thomson-http-mice">[I-D.thomson-http-mice]</b></td>
<td class="top">
<a>Thomson, M.</a>, "<a href="https://tools.ietf.org/html/draft-thomson-http-mice-02">Merkle Integrity Content Encoding</a>", Internet-Draft draft-thomson-http-mice-02, October 2016.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.vkrasnov-h2-compression-dictionaries">[I-D.vkrasnov-h2-compression-dictionaries]</b></td>
<td class="top">
<a>Krasnov, V.</a>, "<a href="https://tools.ietf.org/html/draft-vkrasnov-h2-compression-dictionaries-02">Compression Dictionaries for HTTP/2</a>", Internet-Draft draft-vkrasnov-h2-compression-dictionaries-02, March 2017.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.yasskin-dispatch-web-packaging">[I-D.yasskin-dispatch-web-packaging]</b></td>
<td class="top">
<a>Yasskin, J.</a>, "<a href="https://tools.ietf.org/html/draft-yasskin-dispatch-web-packaging-00">Web Packaging</a>", Internet-Draft draft-yasskin-dispatch-web-packaging-00, June 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6066">[RFC6066]</b></td>
<td class="top">
<a>Eastlake 3rd, D.</a>, "<a href="https://tools.ietf.org/html/rfc6066">Transport Layer Security (TLS) Extensions: Extension Definitions</a>", RFC 6066, DOI 10.17487/RFC6066, January 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6454">[RFC6454]</b></td>
<td class="top">
<a>Barth, A.</a>, "<a href="https://tools.ietf.org/html/rfc6454">The Web Origin Concept</a>", RFC 6454, DOI 10.17487/RFC6454, December 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7541">[RFC7541]</b></td>
<td class="top">
<a>Peon, R.</a> and <a>H. Ruellan</a>, "<a href="https://tools.ietf.org/html/rfc7541">HPACK: Header Compression for HTTP/2</a>", RFC 7541, DOI 10.17487/RFC7541, May 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8017">[RFC8017]</b></td>
<td class="top">
<a>Moriarty, K.</a>, <a>Kaliski, B.</a>, <a>Jonsson, J.</a> and <a>A. Rusch</a>, "<a href="https://tools.ietf.org/html/rfc8017">PKCS #1: RSA Cryptography Specifications Version 2.2</a>", RFC 8017, DOI 10.17487/RFC8017, November 2016.</td>
</tr>
<tr>
<td class="reference"><b id="SRI">[SRI]</b></td>
<td class="top">
<a>Akhawe, D.</a>, <a>Braun, F.</a>, <a>Marier, F.</a> and <a>J. Weinberger</a>, "<a href="http://www.w3.org/TR/2016/REC-SRI-20160623">Subresource Integrity</a>", World Wide Web Consortium Recommendation REC-SRI-20160623, June 2016.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#use-cases" id="use-cases">Use cases</a>
</h1>
<h1 id="rfc.appendix.A.1">
<a href="#rfc.appendix.A.1">A.1.</a> <a href="#uc-pushed-subresources" id="uc-pushed-subresources">PUSHed subresources</a>
</h1>
<p id="rfc.section.A.1.p.1">To reduce round trips, a server might use HTTP/2 PUSH to inject a subresource from another server into the client&#8217;s cache. If anything about the subresource is expired or can&#8217;t be verified, the client would fetch it from the original server.</p>
<p id="rfc.section.A.1.p.2">For example, if <samp>https://example.com/index.html</samp> includes</p>
<pre>
&lt;script src="https://jquery.com/jquery-1.2.3.min.js"&gt;
</pre>
<p id="rfc.section.A.1.p.3">Then to avoid the need to look up and connect to <samp>jquery.com</samp> in the critical path, <samp>example.com</samp> might PUSH that resource (Section 8.2 of <a href="#RFC7540" class="xref">[RFC7540]</a>), signed by <samp>jquery.com</samp>.</p>
<h1 id="rfc.appendix.A.2">
<a href="#rfc.appendix.A.2">A.2.</a> <a href="#uc-explicit-distributor" id="uc-explicit-distributor">Explicit use of a content distributor for subresources</a>
</h1>
<p id="rfc.section.A.2.p.1">In order to speed up loading but still maintain control over its content, an HTML page in a particular origin <samp>O.com</samp> could tell clients to load its subresources from an intermediate content distributor that&#8217;s not authoritative, but require that those resources be signed by <samp>O.com</samp> so that the distributor couldn&#8217;t modify the resources. This is more constrained than the common CDN case where <samp>O.com</samp> has a CNAME granting the CDN the right to serve arbitrary content as <samp>O.com</samp>.</p>
<pre>
&lt;img logicalsrc="https://O.com/img.png"
     physicalsrc="https://distributor.com/O.com/img.png"&gt;
</pre>
<p id="rfc.section.A.2.p.2">To make it easier to configure the right distributor for a given request, computation of the <samp>physicalsrc</samp> could be encapsulated in a custom element:</p>
<pre>
&lt;dist-img src="https://O.com/img.png"&gt;&lt;/dist-img&gt;
</pre>
<p id="rfc.section.A.2.p.3">where the <samp>&lt;dist-img&gt;</samp> implementation generates an appropriate <samp>&lt;img&gt;</samp> based on, for example, a <samp>&lt;meta name="dist-base"&gt;</samp> tag elsewhere in the page. However, this has the downside that the <a href="https://calendar.perfplanet.com/2013/big-bad-preloader/">preloader</a> can no longer see the physical source to download it. The resulting delay might cancel out the benefit of using a distributor.</p>
<p id="rfc.section.A.2.p.4">This could be used for some of the same purposes as SRI (<a href="#uc-sri" class="xref">Appendix A.3</a>).</p>
<p id="rfc.section.A.2.p.5">To implement this with the current proposal, the distributor would respond to the physical request to <samp>https://distributor.com/O.com/img.png</samp> with first a signed PUSH_PROMISE for <samp>https://O.com/img.png</samp> and then a redirect to <samp>https://O.com/img.png</samp>.</p>
<h1 id="rfc.appendix.A.3">
<a href="#rfc.appendix.A.3">A.3.</a> <a href="#uc-sri" id="uc-sri">Subresource Integrity</a>
</h1>
<p id="rfc.section.A.3.p.1">The W3C WebAppSec group is investigating <a href="https://github.com/mikewest/signature-based-sri">using signatures</a> in <a href="#SRI" class="xref">[SRI]</a>.  They need a way to transmit the signature with the response, which this proposal could provide.</p>
<p id="rfc.section.A.3.p.2">However, their needs also differ in some significant ways:</p>
<p></p>

<ol>
<li>The <samp>integrity="ed25519-[public-key]"</samp> attribute and CSP-based ways of expressing a public key don&#8217;t need the signing key to be also trusted to sign arbitrary content for an origin.</li>
<li>Some uses of SRI want to constrain subresources to be vouched for by a third-party, rather than just being signed by the subresource&#8217;s author.</li>
</ol>
<p id="rfc.section.A.3.p.4">While we can design this system to cover both origin-trusted and simple-key signatures, we should check that this is better than having two separate systems for the two kinds of signatures.</p>
<p id="rfc.section.A.3.p.5">Note that while the current proposal for SRI describes signing only the content of a resource, <a href="https://github.com/mikewest/signature-based-sri/issues/5">they may need to sign its name as well, to prevent security vulnerabilities</a>.  The details of what they need to sign will affect whether and how they can use this proposal.</p>
<h1 id="rfc.appendix.A.4">
<a href="#rfc.appendix.A.4">A.4.</a> <a href="#uc-offline-websites" id="uc-offline-websites">Offline websites</a>
</h1>
<p id="rfc.section.A.4.p.1">See <a href="https://github.com/WICG/webpackage">https://github.com/WICG/webpackage</a> and <a href="#I-D.yasskin-dispatch-web-packaging" class="xref">[I-D.yasskin-dispatch-web-packaging]</a>. This use requires origin-signed resources to be bundled.</p>
<h1 id="rfc.appendix.B">
<a href="#rfc.appendix.B">Appendix B.</a> <a href="#requirements" id="requirements">Requirements</a>
</h1>
<h1 id="rfc.appendix.B.1">
<a href="#rfc.appendix.B.1">B.1.</a> <a href="#proof-of-origin" id="proof-of-origin">Proof of origin</a>
</h1>
<p id="rfc.section.B.1.p.1">To verify that a thing came from a particular origin, for use in the same context as a TLS connection, we need someone to vouch for the signing key with as much verification as the signing keys used in TLS. The obvious way to do this is to re-use the web PKI and CA ecosystem.</p>
<h1 id="rfc.appendix.B.1.1">
<a href="#rfc.appendix.B.1.1">B.1.1.</a> <a href="#certificate-constraints" id="certificate-constraints">Certificate constraints</a>
</h1>
<p id="rfc.section.B.1.1.p.1">If we re-use existing TLS server certificates, we incur the risks that:</p>
<p></p>

<ol>
<li>TLS server certificates must be accessible from online servers, so they&#8217;re easier to steal than an offline key. A package&#8217;s signing key doesn&#8217;t need to be online.</li>
<li>A server using an origin-trusted key for one purpose (e.g. TLS) might accidentally sign something that looks like a package, or vice versa.</li>
</ol>
<p id="rfc.section.B.1.1.p.3">If these risks are too high, we could define a new Extended Key Usage (Section 4.2.1.12 of <a href="#RFC5280" class="xref">[RFC5280]</a>) that requires CAs to issue new keys for this purpose or a new certificate extension to do the same. A new EKU would probably require CAs to also issue new intermediate certificates because of how browsers trust EKUs. Both an EKU and a new extension take a long time to deploy and allow CAs to charge package-signers more than normal server operators, which will reduce adoption.</p>
<p id="rfc.section.B.1.1.p.4">The rest of this document will assume we can re-use existing TLS server certificates.</p>
<h1 id="rfc.appendix.B.1.2">
<a href="#rfc.appendix.B.1.2">B.1.2.</a> <a href="#signature-constraints" id="signature-constraints">Signature constraints</a>
</h1>
<p id="rfc.section.B.1.2.p.1">In order to prevent an attacker who can convince the server to sign some resource from causing those signed bytes to be interpreted as something else, signatures here need to:</p>
<p></p>

<ol>
<li>Avoid key types that are used for non-TLS protocols whose output could be confused with a signature. That may be just the <samp>rsaEncryption</samp> OID from <a href="#RFC8017" class="xref">[RFC8017]</a>.</li>
<li>Use the same format as TLS&#8217;s signatures, specified in Section 4.4.3 of <a href="#I-D.ietf-tls-tls13" class="xref">[I-D.ietf-tls-tls13]</a> , with a context string that&#8217;s specific to this use.</li>
</ol>
<p id="rfc.section.B.1.2.p.3">The specification also needs to define which signing algorithm to use. I expect to define that as a function from the key type, instead of allowing attacker-controlled data to specify it.</p>
<h1 id="rfc.appendix.B.1.3">
<a href="#rfc.appendix.B.1.3">B.1.3.</a> <a href="#certificate-chain" id="certificate-chain">Retrieving the certificate</a>
</h1>
<p id="rfc.section.B.1.3.p.1">The client needs to be able to find the certificate vouching for the signing key, a chain from that certificate to a trusted root, and possibly other trust information like SCTs (<a href="#RFC6962" class="xref">[RFC6962]</a>). One approach would be to include the certificate and its chain in the signature metadata itself, but this wastes bytes when the same certificate is used for multiple HTTP responses. If we decide to put the signature in an HTTP header, certificates are also unusually large for that context.</p>
<p id="rfc.section.B.1.3.p.2">Another option is to pass a URL that the client can fetch to retrieve the certificate and chain. To avoid extra round trips in fetching that URL, it could be <a href="#uc-offline-websites" class="xref">bundled</a> with the signed content or <a href="#uc-pushed-subresources" class="xref">PUSHed</a> with it. The risks from the <samp>client_certificate_url</samp> extension (Section 11.3 of <a href="#RFC6066" class="xref">[RFC6066]</a>) don&#8217;t seem to apply here, since an attacker who can get a client to load a package and fetch the certificates it references, can also get the client to perform those fetches by loading other HTML.</p>
<p id="rfc.section.B.1.3.p.3">To avoid using an unintended certificate with the same public key as the intended one, the content of the certificate chain should be included in the signed data, like TLS does (Section 4.4.3 of <a href="#I-D.ietf-tls-tls13" class="xref">[I-D.ietf-tls-tls13]</a>).</p>
<h1 id="rfc.appendix.B.2">
<a href="#rfc.appendix.B.2">B.2.</a> <a href="#how-much-to-sign" id="how-much-to-sign">How much to sign</a>
</h1>
<p id="rfc.section.B.2.p.1">The previous <a href="#I-D.thomson-http-content-signature" class="xref">[I-D.thomson-http-content-signature]</a> and <a href="#I-D.burke-content-signature" class="xref">[I-D.burke-content-signature]</a> schemes signed just the content, while (<a href="#I-D.cavage-http-signatures" class="xref">[I-D.cavage-http-signatures]</a> could also sign the response headers and the request method and path. However, the same path, response headers, and content may mean something very different when retrieved from a different server.  <a href="#significant-parts" class="xref">Section 3.3</a> currently includes the whole request URL in the signature, but it&#8217;s possible we need a more flexible scheme to allow some higher-level protocols to accept a less-signed URL.</p>
<p id="rfc.section.B.2.p.2">The question of whether to include other request headers&#8212;primarily the <samp>accept*</samp> family&#8212;is still open. These headers need to be represented so that clients wanting a different language, say, can avoid using the wrong-language response, but it&#8217;s not obvious that there&#8217;s a security vulnerability if an attacker can spoof them. For now, the proposal (<a href="#proposal" class="xref">Section 3</a>) omits other request headers.</p>
<p id="rfc.section.B.2.p.3">In order to allow multiple clients to consume the same signed exchange, the exchange shouldn&#8217;t include the exact request headers that any particular client sends. For example, a Japanese resource wouldn&#8217;t include</p>
<pre>
accept-language: ja-JP, ja;q=0.9, en;q=0.8, zh;q=0.7, *;q=0.5
</pre>
<p id="rfc.section.B.2.p.4">Instead, it would probably include just</p>
<pre>
accept-language: ja-JP, ja
</pre>
<p id="rfc.section.B.2.p.5">and clients would use the same matching logic as for <a href="https://tools.ietf.org/html/rfc7540#section-8.2">PUSH_PROMISE</a> frame headers.</p>
<h1 id="rfc.appendix.B.2.1">
<a href="#rfc.appendix.B.2.1">B.2.1.</a> <a href="#conveying-the-signed-headers" id="conveying-the-signed-headers">Conveying the signed headers</a>
</h1>
<p id="rfc.section.B.2.1.p.1">HTTP headers are traditionally munged by proxies, making it impossible to guarantee that the client will see the same sequence of bytes as the author wrote. In the HTTPS world, we have more end-to-end header integrity, but it&#8217;s still likely that there are enough TLS-terminating proxies that the author&#8217;s signatures would tend to break before getting to the client.</p>
<p id="rfc.section.B.2.1.p.2">There&#8217;s also no way in current HTTP for the response to a client-initiated request (Section 8.1 of <a href="#RFC7540" class="xref">[RFC7540]</a>) to convey the request headers it expected to respond to. A PUSH_PROMISE (Section 8.2 of <a href="#RFC7540" class="xref">[RFC7540]</a>) does not have this problem, and it would be possible to introduce a response header to convey the expected request headers.</p>
<p id="rfc.section.B.2.1.p.3">Since proxies are unlikely to modify unknown content types, we could wrap the original exchange into an <samp>application/http2</samp> format and include the <samp>Cache-Control: no-transform</samp> header when sending it. This format could be as simple as a series of HTTP/2 frames, or could</p>
<p></p>

<ol>
<li>Allow longer contiguous bodies than <a href="https://tools.ietf.org/html/rfc7540#section-4.2">HTTP/2&#8217;s 16MB frame limit</a>, and</li>
<li>Use better compression than <a href="#RFC7541" class="xref">[RFC7541]</a> for the non-confidential headers.  Note that header compression can probably share a compression state across a single signed exchange, but needs a mechanism like <a href="#I-D.vkrasnov-h2-compression-dictionaries" class="xref">[I-D.vkrasnov-h2-compression-dictionaries]</a> to use any compression state from other responses.</li>
</ol>
<p id="rfc.section.B.2.1.p.5">To reduce the likelihood of accidental modification by proxies, an <samp>application/http2</samp> format should be sure to include a file signature that doesn&#8217;t collide with other known signatures.</p>
<p id="rfc.section.B.2.1.p.6">To help the PUSHed subresources use case (<a href="#uc-pushed-subresources" class="xref">Appendix A.1</a>), we might also want to extend the <samp>PUSH_PROMISE</samp> frame type to include a signature, and that could tell intermediates not to change the ensuing headers.</p>
<h1 id="rfc.appendix.B.3">
<a href="#rfc.appendix.B.3">B.3.</a> <a href="#response-lifespan" id="response-lifespan">Response lifespan</a>
</h1>
<p id="rfc.section.B.3.p.1">A normal HTTPS response is authoritative only for one client, for as long as its cache headers say it should live. A signed exchange can be re-used for many clients, and if it was generated while a server was compromised, it can continue compromising clients even if their requests happen after the server recovers.  This signing scheme needs to mitigate that risk.</p>
<h1 id="rfc.appendix.B.3.1">
<a href="#rfc.appendix.B.3.1">B.3.1.</a> <a href="#certificate-revocation" id="certificate-revocation">Certificate revocation</a>
</h1>
<p id="rfc.section.B.3.1.p.1">Certificates are mis-issued and private keys are stolen, and in response clients need to be able to stop trusting these certificates as promptly as possible.  Online revocation checks <a href="https://www.imperialviolet.org/2012/02/05/crlsets.html">don&#8217;t work</a>, so the industry has moved to pushed revocation lists and stapled OCSP responses <a href="#RFC6066" class="xref">[RFC6066]</a>.</p>
<p id="rfc.section.B.3.1.p.2">Pushed revocation lists work as-is to block trust in the certificate signing an exchange, but the signatures need an explicit strategy to staple OCSP responses.  One option is to extend the certificate download (<a href="#certificate-chain" class="xref">Appendix B.1.3</a>) to include the OCSP response too, perhaps in the <a href="https://tlswg.github.io/tls13-spec/draft-ietf-tls-tls13.html#ocsp-and-sct">TLS 1.3 CertificateEntry</a> format.</p>
<h1 id="rfc.appendix.B.3.2">
<a href="#rfc.appendix.B.3.2">B.3.2.</a> <a href="#downgrade" id="downgrade">Response downgrade attacks</a>
</h1>
<p id="rfc.section.B.3.2.p.1">The signed content in a response might be vulnerable to attacks, such as XSS, or might simply be discovered to be incorrect after publication. Once the author fixes those vulnerabilities or mistakes, clients should stop trusting the old signed content in a reasonable amount of time. Similar to certificate revocation, I expect the best option to be stapled &#8220;this version is still valid&#8221; assertions with short expiration times.</p>
<p id="rfc.section.B.3.2.p.2">These assertions could be structured as:</p>
<p></p>

<ol>
<li>A signed minimum version number or timestamp for a set of request headers: This requires that signed responses need to include a version number or timestamp, but allows a server to provide a single signature covering all valid versions.</li>
<li>A replacement for the whole exchange&#8217;s signature. This requires the author to separately re-sign each valid version and requires each version to include a different update URL, but allows intermediates to serve less data. This is the approach taken in <a href="#proposal" class="xref">Section 3</a>.</li>
<li>A replacement for the exchange&#8217;s signature and an update for the embedded <samp>expires</samp> and related cache-control HTTP headers <a href="#RFC7234" class="xref">[RFC7234]</a>. This naturally extends authors&#8217; intuitions about cache expiration and the existing cache revalidation behavior to signed exchanges. This is sketched and its downsides explored in <a href="#validity-with-cache-control" class="xref">Appendix C</a>.</li>
</ol>
<p id="rfc.section.B.3.2.p.4">The signature also needs to include instructions to intermediates for how to fetch updated validity assertions.</p>
<h1 id="rfc.appendix.C">
<a href="#rfc.appendix.C">Appendix C.</a> <a href="#validity-with-cache-control" id="validity-with-cache-control">Determining validity using cache control</a>
</h1>
<p id="rfc.section.C.p.1">This draft could expire signature validity using the normal HTTP cache control headers (<a href="#RFC7234" class="xref">[RFC7234]</a>) instead of embedding an expiration date in the signature itself. This section specifies how that would work, and describes why I haven&#8217;t chosen that option.</p>
<p id="rfc.section.C.p.2">The signatures in the <samp>Signature</samp> header field (<a href="#signature-header" class="xref">Section 3.2</a>) would no longer contain &#8220;date&#8221; or &#8220;expires&#8221; fields.</p>
<p id="rfc.section.C.p.3">The validity-checking algorithm (<a href="#signature-validity" class="xref">Section 3.6</a>) would initialize <samp>date</samp> from the resource&#8217;s <samp>Date</samp> header field (Section 7.1.1.2 of <a href="#RFC7231" class="xref">[RFC7231]</a>) and initialize <samp>expires</samp> from either the <samp>Expires</samp> header field (Section 5.3 of <a href="#RFC7234" class="xref">[RFC7234]</a>) or the <samp>Cache-Control</samp> header field&#8217;s <samp>max-age</samp> directive (Section 5.2.2.8 of <a href="#RFC7234" class="xref">[RFC7234]</a>) (added to <samp>date</samp>), whichever is present, preferring <samp>max-age</samp> (or failing) if both are present.</p>
<p id="rfc.section.C.p.4">Validity updates (<a href="#updating-validity" class="xref">Section 3.7</a>) would include a list of replacement response header fields. For each header field name in this list, the client would remove matching header fields from the stored exchange&#8217;s response header fields. Then the client would append the replacement header fields to the stored exchange&#8217;s response header fields.</p>
<h1 id="rfc.appendix.C.1">
<a href="#rfc.appendix.C.1">C.1.</a> <a href="#example-of-updating-cache-control" id="example-of-updating-cache-control">Example of updating cache control</a>
</h1>
<p id="rfc.section.C.1.p.1">For example, given a stored exchange of:</p>
<pre>
GET https://example.com/ HTTP/1.1
Accept: */*

HTTP/1.1 200
Date: Mon, 20 Nov 2017 10:00:00 UTC
Content-Type: text/html
Date: Tue, 21 Nov 2017 10:00:00 UTC
Expires: Sun, 26 Nov 2017 10:00:00 UTC

&lt;!doctype html&gt;
&lt;html&gt;
...
</pre>
<p id="rfc.section.C.1.p.2">And an update listing the following headers:</p>
<pre>
Expires: Fri, 1 Dec 2017 10:00:00 UTC
Date: Sat, 25 Nov 2017 10:00:00 UTC
</pre>
<p id="rfc.section.C.1.p.3">The resulting stored exchange would be:</p>
<pre>
GET https://example.com/ HTTP/1.1
Accept: */*

HTTP/1.1 200
Content-Type: text/html
Expires: Fri, 1 Dec 2017 10:00:00 UTC
Date: Sat, 25 Nov 2017 10:00:00 UTC

&lt;!doctype html&gt;
&lt;html&gt;
...
</pre>
<h1 id="rfc.appendix.C.2">
<a href="#rfc.appendix.C.2">C.2.</a> <a href="#downsides-of-cache-control" id="downsides-of-cache-control">Downsides of updating cache control</a>
</h1>
<p id="rfc.section.C.2.p.1">In an exchange with multiple signatures, using cache control to expire signatures forces all signatures to initially live for the same period. Worse, the update from one signature&#8217;s &#8220;validityUrl&#8221; might not match the update for another signature. Clients would need to maintain a current set of headers for each signature, and then decide which set to use when actually parsing the resource itself.</p>
<p id="rfc.section.C.2.p.2">This need to store and reconcile multiple sets of headers for a single signed exchange argues for embedding a signature&#8217;s lifetime into the signature.</p>
<h1 id="rfc.appendix.D">
<a href="#rfc.appendix.D">Appendix D.</a> <a href="#acknowledgements" id="acknowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.D.p.1">Thanks to Ilari Liusvaara, Mark Nottingham, Mike Bishop, Ryan Sleevi, and Yoav Weiss for comments that improved this draft.</p>
<h1 id="rfc.authors"><a href="#rfc.authors">Author's Address</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Jeffrey Yasskin</span> 
	  <span class="n hidden">
		<span class="family-name">Yasskin</span>
	  </span>
	</span>
	<span class="org vcardline">Google</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:jyasskin@chromium.org">jyasskin@chromium.org</a></span>

  </address>
</div>

  <div class="github-fork-ribbon-wrapper"><div class="github-fork-ribbon"><a href="https://github.com/WICG/webpackage">Fork me on GitHub</a></div></div>
</body>
</html>
