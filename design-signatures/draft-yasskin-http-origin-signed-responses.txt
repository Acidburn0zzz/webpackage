



http                                                          J. Yasskin
Internet-Draft                                                    Google
Intended status: Standards Track                       November 21, 2017
Expires: May 25, 2018


                      Origin-signed HTTP Responses
           draft-yasskin-http-origin-signed-responses-latest

Abstract

   This document explores how a server can send particular responses
   that are authoritative for an origin, when the server itself is not
   authoritative for that origin.  For now, it focuses on the
   constraints covering any such mechanism.

Note to Readers

   Discussion of this draft takes place on the HTTP working group
   mailing list (ietf-http-wg@w3.org), which is archived at
   https://lists.w3.org/Archives/Public/ietf-http-wg/ [1].

   The source code and issues list for this draft can be found in
   https://github.com/WICG/webpackage [2].

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on May 25, 2018.

Copyright Notice

   Copyright (c) 2017 IETF Trust and the persons identified as the
   document authors.  All rights reserved.





Yasskin                   Expires May 25, 2018                  [Page 1]

Internet-Draft        Origin-signed HTTP Responses         November 2017


   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (https://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
   2.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   3
   3.  Use cases . . . . . . . . . . . . . . . . . . . . . . . . . .   3
     3.1.  PUSHed subresources . . . . . . . . . . . . . . . . . . .   3
     3.2.  Explicit use of a CDN for subresources  . . . . . . . . .   4
     3.3.  Subresource Integrity . . . . . . . . . . . . . . . . . .   4
     3.4.  Offline websites  . . . . . . . . . . . . . . . . . . . .   5
   4.  Requirements and open questions . . . . . . . . . . . . . . .   5
     4.1.  Proof of origin . . . . . . . . . . . . . . . . . . . . .   5
       4.1.1.  Certificate constraints . . . . . . . . . . . . . . .   5
       4.1.2.  Signature constraints . . . . . . . . . . . . . . . .   6
       4.1.3.  Retrieving the certificate  . . . . . . . . . . . . .   6
     4.2.  How much to sign  . . . . . . . . . . . . . . . . . . . .   7
     4.3.  Response lifespan . . . . . . . . . . . . . . . . . . . .   7
       4.3.1.  Certificate revocation  . . . . . . . . . . . . . . .   7
       4.3.2.  Response downgrade attacks  . . . . . . . . . . . . .   8
     4.4.  Conveying the signed headers  . . . . . . . . . . . . . .   8
   5.  Straw proposal  . . . . . . . . . . . . . . . . . . . . . . .   9
     5.1.  The Signed-Request-Headers and Signed-Response-Headers
           Headers . . . . . . . . . . . . . . . . . . . . . . . . .  10
     5.2.  The Signature Header  . . . . . . . . . . . . . . . . . .  10
       5.2.1.  Open Questions  . . . . . . . . . . . . . . . . . . .  11
     5.3.  Content of a signed exchange  . . . . . . . . . . . . . .  11
     5.4.  application/http2 content type  . . . . . . . . . . . . .  11
       5.4.1.  Example . . . . . . . . . . . . . . . . . . . . . . .  13
     5.5.  Significant parts of an exchange  . . . . . . . . . . . .  13
     5.6.  Signature validity  . . . . . . . . . . . . . . . . . . .  14
       5.6.1.  Open Questions  . . . . . . . . . . . . . . . . . . .  17
     5.7.  Updating signature validity . . . . . . . . . . . . . . .  17
       5.7.1.  Examples  . . . . . . . . . . . . . . . . . . . . . .  18
   6.  Security considerations . . . . . . . . . . . . . . . . . . .  20
   7.  Privacy considerations  . . . . . . . . . . . . . . . . . . .  20
   8.  IANA considerations . . . . . . . . . . . . . . . . . . . . .  21
   9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  21
     9.1.  Normative References  . . . . . . . . . . . . . . . . . .  21
     9.2.  Informative References  . . . . . . . . . . . . . . . . .  22



Yasskin                   Expires May 25, 2018                  [Page 2]

Internet-Draft        Origin-signed HTTP Responses         November 2017


     9.3.  URIs  . . . . . . . . . . . . . . . . . . . . . . . . . .  24
   Appendix A.  Acknowledgements . . . . . . . . . . . . . . . . . .  24
   Author's Address  . . . . . . . . . . . . . . . . . . . . . . . .  24

1.  Introduction

   When I presented Web Packaging to DISPATCH [3], folks thought it
   would make sense to split it into a way to sign individual HTTP
   responses as coming from a particular origin, and separately a way to
   bundle a collection of HTTP responses.  This document explores the
   constraints on any method of signing HTTP responses and sketches a
   possible solution to the constraints.

2.  Terminology

   Author  The entity that controls the server for a particular origin
      [RFC6454].  The author can get a CA to issue certificates for
      their private keys and can run a TLS server for their origin.

   Exchange (noun)  An HTTP request from a client and the matching
      response from a server.  These make up an entire HTTP/2 stream or
      a contiguous block of an HTTP/1 connection.  Defined by [RFC7540]
      section 8.

   Intermediate  An entity that fetches signed HTTP exchanges from an
      author or another intermediate and forwards them to another
      intermediate or a client.

   Client  An entity that uses a signed HTTP exchange and needs to be
      able to prove that the author vouched for it as coming from its
      claimed origin.

   Unix time  Defined by [POSIX] section 4.16 [4].

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in BCP
   14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

3.  Use cases

3.1.  PUSHed subresources

   To reduce round trips, a server might use HTTP/2 PUSH to inject a
   subresource from another server into the client's cache.  If anything
   about the subresource is expired or can't be verified, the client
   would fetch it from the original server.



Yasskin                   Expires May 25, 2018                  [Page 3]

Internet-Draft        Origin-signed HTTP Responses         November 2017


   For example, if "https://example.com/index.html" includes

   <script src="https://jquery.com/jquery-1.2.3.min.js">

   Then to avoid the need to look up and connect to "jquery.com" in the
   critical path, "example.com" might PUSH that resource ([RFC7540],
   section 8.2), signed by "jquery.com".

3.2.  Explicit use of a CDN for subresources

   In order to speed up loading but still maintain control over its
   content, an HTML page in a particular origin "O.com" could tell
   clients to load its subresources from an intermediate CDN that's not
   authoritative, but require that those resources be signed by "O.com"
   so that the CDN couldn't modify the resources.

   <img logicalsrc="https://O.com/img.png"
        physicalsrc="https://cdn.com/O.com/img.png">

   To make it easier to configure the right CDN for a given request,
   computation of the "physicalsrc" could be encapsulated in a custom
   element:

   <cdn-img src="https://O.com/img.png"></cdn-img>

   where the "<cdn-img>" implementation generates an appropriate "<img>"
   based on, for example, a "<meta name="cdn-base">" tag elsewhere in
   the page.

   This could be used for some of the same purposes as SRI
   (Section 3.3).

3.3.  Subresource Integrity

   The W3C WebAppSec group is investigating using signatures [5] in
   [SRI].  They need a way to transmit the signature with the response,
   which this proposal could provide.

   However, their needs also differ in some significant ways:

   1.  The "integrity="ed25519-[public-key]"" attribute and CSP-based
       ways of expressing a public key don't need the signing key to be
       also trusted to sign arbitrary content for an origin.

   2.  Some uses of SRI want to constrain subresources to be vouched for
       by a third-party, rather than just being signed by the
       subresource's author.




Yasskin                   Expires May 25, 2018                  [Page 4]

Internet-Draft        Origin-signed HTTP Responses         November 2017


   While we can design this system to cover both origin-trusted and
   simple-key signatures, we should check that this is better than
   having two separate systems for the two kinds of signatures.

   Note that while the current proposal for SRI describes signing only
   the content of a resource, they may need to sign its name as well, to
   prevent security vulnerabilities [6].  The details of what they need
   to sign will affect whether and how they can use this proposal.

3.4.  Offline websites

   See https://github.com/WICG/webpackage [7] and
   [I-D.yasskin-dispatch-web-packaging].  This use requires origin-
   signed resources to be bundled.

4.  Requirements and open questions

4.1.  Proof of origin

   To verify that a thing came from a particular origin, for use in the
   same context as a TLS connection, we need someone to vouch for the
   signing key with as much verification as the signing keys used in
   TLS.  The obvious way to do this is to re-use the web PKI and CA
   ecosystem.

4.1.1.  Certificate constraints

   If we re-use existing TLS server certificates, we incur the risks
   that:

   1.  TLS server certificates must be accessible from online servers,
       so they're easier to steal than an offline key.  A package's
       signing key doesn't need to be online.

   2.  A server using an origin-trusted key for one purpose (e.g.  TLS)
       might accidentally sign something that looks like a package, or
       vice versa.

   If these risks are too high, we could define a new Extended Key Usage
   ([RFC5280], section 4.2.1.12) that requires CAs to issue new keys for
   this purpose or a new certificate extension to do the same.  A new
   EKU would probably require CAs to also issue new intermediate
   certificates because of how browsers trust EKUs.  Both an EKU and a
   new extension take a long time to deploy and allow CAs to charge
   package-signers more than normal server operators, which will reduce
   adoption.





Yasskin                   Expires May 25, 2018                  [Page 5]

Internet-Draft        Origin-signed HTTP Responses         November 2017


   The rest of this document will assume we can re-use existing TLS
   server certificates.

4.1.2.  Signature constraints

   In order to prevent an attacker who can convince the server to sign
   some resource from causing those signed bytes to be interpreted as
   something else, signatures here need to:

   1.  Avoid key types that are used for non-TLS protocols whose output
       could be confused with a signature.  That may be just the
       "rsaEncryption" OID from [RFC2437].

   2.  Use the same format as TLS's signatures, specified in
       [I-D.ietf-tls-tls13] section 4.4.3, with a context string that's
       specific to this use.

   The specification also needs to define which signing algorithm to
   use.  I expect to define that as a function from the key type,
   instead of allowing attacker-controlled data to specify it.

4.1.3.  Retrieving the certificate

   The client needs to be able to find the certificate vouching for the
   signing key, a chain from that certificate to a trusted root, and
   possibly other trust information like SCTs ([RFC6962]).  One approach
   would be to include the certificate and its chain in the signature
   metadata itself, but this wastes bytes when the same certificate is
   used for multiple HTTP responses.  If we decide to put the signature
   in an HTTP header, certificates are also unusually large for that
   context.

   Another option is to pass a URL that the client can fetch to retrieve
   the certificate and chain.  To avoid extra round trips in fetching
   that URL, it could be bundled (Section 3.4) with the signed content
   or PUSHed (Section 3.1) with it.  The risks from the
   "client_certificate_url" extension ([RFC6066] section 11.3) don't
   seem to apply here, since an attacker who can get a client to load a
   package and fetch the certificates it references, can also get the
   client to perform those fetches by loading other HTML.

   To avoid using an unintended certificate with the same public key as
   the intended one, the content of the certificate chain should be
   included in the signed data, like TLS does ([I-D.ietf-tls-tls13],
   section 4.4.3).






Yasskin                   Expires May 25, 2018                  [Page 6]

Internet-Draft        Origin-signed HTTP Responses         November 2017


4.2.  How much to sign

   The previous [I-D.thomson-http-content-signature] and
   [I-D.burke-content-signature] schemes signed just the content, while
   ([I-D.cavage-http-signatures] could also sign the response headers
   and the request method and path.  However, the same path, response
   headers, and content may mean something very different when retrieved
   from a different server, so this document expects to include the
   whole URL in the signed data as well.

   The question of whether to include other request headers--primarily
   the "accept*" family--is still open.  These headers need to be
   represented so that clients wanting a different language, say, can
   avoid using the wrong-language response, but it's not obvious that
   there's a security vulnerability if an attacker can spoof them.  That
   said, it's always safer to include everything in the signature.

   In order to allow multiple clients to consume the same signed
   response, the response shouldn't include the exact headers that any
   particular client sends.  For example, a Japanese resource wouldn't
   include

   accept-language: ja-JP, ja;q=0.9, en;q=0.8, zh;q=0.7, *;q=0.5

   Instead, it would probably include just

   accept-language: ja-JP, ja

   and clients would use the same matching logic as for PUSH_PROMISE [8]
   frame headers.

   The rest of this document will assume that all request headers are
   included in the signature.

4.3.  Response lifespan

   A normal HTTPS response is authoritative only for one client, for as
   long as its cache headers say it should live.  A signed exchange can
   be re-used for many clients, and if it was generated while a server
   was compromised, it can continue compromising clients even if their
   requests happen after the server recovers.  This signing scheme needs
   to mitigate that risk.

4.3.1.  Certificate revocation

   Certificates are mis-issued and private keys are stolen, and in
   response clients need to be able to stop trusting these certificates
   as promptly as possible.  Online revocation checks don't work [9], so



Yasskin                   Expires May 25, 2018                  [Page 7]

Internet-Draft        Origin-signed HTTP Responses         November 2017


   the industry has moved to pushed revocation lists and stapled OCSP
   responses [RFC6066].

   Pushed revocation lists work as-is to block trust in the certificate
   signing an exchange, but the signatures need an explicit strategy to
   staple OCSP responses.  One option is to extend the certificate
   download (Section 4.1.3) to include the OCSP response too, perhaps in
   the TLS 1.3 CertificateEntry [10] format.

4.3.2.  Response downgrade attacks

   The signed content in a response might be vulnerable to attacks, such
   as XSS, or might simply be discovered to be incorrect after
   publication.  Once the author fixes those vulnerabilities or
   mistakes, clients should stop trusting the old signed content in a
   reasonable amount of time.  Similar to certificate revocation, I
   expect the best option to be stapled "this version is still valid"
   assertions with short expiration times.

   These assertions could be structured as:

   1.  A signed minimum version number or timestamp for a set of request
       headers: This requires that signed responses need to include a
       version number or timestamp, but allows a server to provide a
       single signature covering all valid versions.

   2.  A replacement for the whole exchange's signature.  This requires
       the author to separately re-sign each valid version and requires
       each version to include a strong validator [RFC7232], but allows
       intermediates to serve less data.

   3.  A replacement for the exchange's signature and an update for the
       embedded "expires" and related cache-control HTTP headers
       [RFC7234].  This naturally extends authors' intuitions about
       cache expiration and the existing cache revalidation behavior to
       signed exchanges.  However, it also requires that the update
       procedure for the response headers on the client must produce
       something that's bytewise identical to the updated headers on the
       server.

   The signature also needs to include instructions to intermediates for
   how to fetch updated validity assertions.

4.4.  Conveying the signed headers

   HTTP headers are traditionally munged by proxies, making it
   impossible to guarantee that the client will see the same sequence of
   bytes as the author wrote.  In the HTTPS world, we have more end-to-



Yasskin                   Expires May 25, 2018                  [Page 8]

Internet-Draft        Origin-signed HTTP Responses         November 2017


   end header integrity, but it's still likely that there are enough
   TLS-terminating proxies that the author's signatures would tend to
   break before getting to the client.

   Since proxies don't modify unknown content types, I expect to propose
   an "application/http2" format to serialize the request headers,
   response headers, and body so they can be signed.  This could be as
   simple as a series of HTTP/2 frames, or could

   1.  Allow longer contiguous bodies than HTTP/2's 16MB frame limit
       [11], and

   2.  Use better compression than [RFC7541] for the non-confidential
       headers.  Note that header compression can probably share a
       compression state across a single signed exchange, but probably
       cannot use any compression state from other responses.

   To help the PUSHed subresources use case (Section 3.1), we might also
   want to extend the "PUSH_PROMISE" frame type to include a signature,
   and then there might be some way to include the request headers
   directly in that frame.

5.  Straw proposal

   As a response to an HTTP request (the "physical request"), or as a
   Server Push ([RFC7540], section 8.2) the server MAY send a "logical
   request" and its response, with significant headers identified by
   "Signed-Request-Headers" and "Signed-Response-Headers" headers
   (Section 5.1), and with signatures included in one or more
   "Signature" headers (Section 5.2).

   The client reconstructs the "significant" parts of the exchange
   (Section 5.5) either by taking the sent "application/http2"
   (Section 5.4) content directly or by building an "application/http2"
   item from the significant request and response headers and the
   response payload.  Then it categorizes each "Signature" header as
   "valid" or "invalid" by validating that header's certificate,
   metadata, and signature against the significant parts of the pair
   (Section 5.6).  This validity then informs higher-level protocols.

   The "Signature" header includes information to let a client fetch
   assurance a signed exchange is still valid, in the face of revoked
   certificates and newly-discovered vulnerabilities.  This assurance
   can be bundled back into the signed exchange and forwarded to another
   client, which won't have to re-fetch this validity information for
   some period of time.





Yasskin                   Expires May 25, 2018                  [Page 9]

Internet-Draft        Origin-signed HTTP Responses         November 2017


5.1.  The Signed-Request-Headers and Signed-Response-Headers Headers

   Each of the "Signed-Request-Headers" and "Signed-Response-Headers"
   headers identifies an ordered list of request and response,
   respectively, header field names to include in a signature.  These
   lists of header field names need to be consistent across all
   signatures of an exchange, to avoid forcing higher-level protocols to
   merge the header field lists of valid signatures, so they're provided
   by headers instead of being included in the "Signature" header field.

   "Signed-Request-Headers" and "Signed-Response-Headers" are Structured
   Headers as defined by [I-D.nottingham-structured-headers].  Their
   values MUST be lists ([I-D.nottingham-structured-headers], section
   4.7) of lowercase strings ([I-D.nottingham-structured-headers],
   section 4.2) naming HTTP headers, following the ordering and
   lowercasing rules from [RFC7540], section 8.1.2.

5.2.  The Signature Header

   The "Signature" header conveys a signature for an exchange and
   information about how to determine the authority of and refresh that
   signature.

   The "Signature" header is a Structured Header as defined by
   [I-D.nottingham-structured-headers].  Its value MUST be a dictionary
   ([I-D.nottingham-structured-headers], section 4.7).

   The dictionary MUST contain:

   o  A member whose key is "certUrl" and whose value is a string
      ([I-D.nottingham-structured-headers], section 4.2) containing a
      valid URL string [12].

   o  A member whose key is "certSha256" and whose value is binary
      content ([I-D.nottingham-structured-headers], section 4.5) holding
      the SHA-256 hash of the first certificate found at "certUrl".

   o  A member whose key is "validityUrl" and whose value is a string
      ([I-D.nottingham-structured-headers], section 4.2) containing a
      valid URL string [13].

   o  A member whose key is "date" and whose value is an unsigned
      integer ([I-D.nottingham-structured-headers], section 4.1)
      representing a Unix time.

   o  A member whose key is "expires" and whose value is an unsigned
      integer ([I-D.nottingham-structured-headers], section 4.1)
      representing a Unix time.



Yasskin                   Expires May 25, 2018                 [Page 10]

Internet-Draft        Origin-signed HTTP Responses         November 2017


   o  A member whose key is "sig" and whose value is binary content
      ([I-D.nottingham-structured-headers], section 4.5) holding the
      signature of most of this header and the significant parts of the
      exchange Section 5.5.

   The "certUrl" and "validityUrl" members are _not_ signed, so
   intermediates can update them with pointers to cached versions.

5.2.1.  Open Questions

   Should the certUrl and validityUrl be lists so that intermediates can
   offer a cache without losing the original URLs?  Putting lists in
   dictionary fields is more complex than
   [I-D.nottingham-structured-headers] allows, but Mark might be willing
   to update that.

5.3.  Content of a signed exchange

   The payload of a signed exchange can appear in one of two forms:

   1.  "application/http2" content describing the exact request and
       response headers for the logical request (Section 5.4).

   2.  The payload of the logical response.

   In the first case, "Signed-Request-Headers" and "Signed-Response-
   Headers" header fields MUST NOT appear.  In the second case, they
   MUST appear and identify which headers are significant and in which
   order.

5.4.  application/http2 content type

   The "application/http2" content type encodes an HTTP2 ([RFC7540])
   exchange, including an ordered list of pseudo and normal request
   header fields, optionally a request body, an ordered list of pseudo
   and normal response header fields, a payload body, and optionally an
   ordered list of trailer header fields.

   This content type is *not* simply the concatenation of a sequence of
   HTTP/2 frames ([RFC7540], section 6).  Using this concatenation would
   have the two downsides that 1) there's no canonical form

   This content type consists of a canonical CBOR ([RFC7049], section
   3.9) array containing alternating member names encoded as text
   strings, [RFC7049], section 2.1), and member values, each consisting
   of a single CBOR item with a type and meaning determined by the
   member name.




Yasskin                   Expires May 25, 2018                 [Page 11]

Internet-Draft        Origin-signed HTTP Responses         November 2017


   Note that this format does not use CBOR dictionaries, so that it can
   specify a natural order for the members.

   This specification defines the following member names with their
   associated values:

   "request"  An array of alternating request header field names and
      header field values, encoded as byte strings ([RFC7049], section
      2.1), following the ordering and lowercasing rules from [RFC7540],
      section 8.1.2.

   "request payload"  A byte string ([RFC7049], section 2.1) containing
      the request payload body.

   "response"  An array of alternating response header field names and
      header field values, encoded as byte strings ([RFC7049], section
      2.1), following the ordering and lowercasing rules from [RFC7540]
      section 8.1.2.

   "payload"  A byte string ([RFC7049], section 2.1) containing the
      response payload body ([RFC7230], section 3.3).

   "trailer"  An array of alternating trailer header field names and
      header field values, encoded as byte strings ([RFC7049], section
      2.1), following the ordering and lowercasing rules from [RFC7540]
      section 8.1.2.

   A parser MAY return incremental information while parsing
   "application/http2" content.

   Members "request", "response", and "payload" MUST be present.  If one
   is missing, the parser MUST stop and report an error.

   The member names MUST appear in the order:

   1.  "request"

   2.  "request payload"

   3.  "response"

   4.  "payload"

   5.  "trailer"

   If a member name is not a text string, appears out of order, or is
   followed by a value not matching its description above, the parser
   MUST stop and report an error.



Yasskin                   Expires May 25, 2018                 [Page 12]

Internet-Draft        Origin-signed HTTP Responses         November 2017


   If the parser encounters an unknown member name, it MUST skip the
   following item and resume parsing at the next member name.

5.4.1.  Example

   An example "application/http2" file representing a possible exchange
   with https://example.com/ [14] follows, in the extended diagnostic
   format defined in [I-D.ietf-cbor-cddl] appendix G:

   [
     "request",
     [
       ':method', 'GET',
       ':scheme', 'https',
       ':authority', 'example.com',
       ':path', '/',
       'accept', '*/*'
     ],
     "response",
     [
       ':status', '200',
       'content-type', 'text/html'
     ],
     "payload",
     '<!doctype html>\r\n<html>...'
   ]

5.5.  Significant parts of an exchange

   The significant parts of an exchange are either an "application/
   http2" item (Section 5.4) or a failure.

   If the "Content-Type" ([RFC7231]) of the response is "application/
   http2" and neither the "Signed-Request-Headers" nor the "Signed-
   Response-Headers" header field is present, the significant parts are
   the payload itself.  If either of those header fields is present,
   computing the significant parts fails.

   Otherwise (the "Content-Type" is not "application/http2"), if either
   of the "Signed-Request-Headers" or the "Signed-Response-Headers"
   header field is missing, or if either throws an error while parsing
   as the structured header defined in Section 5.1, computing the
   significant parts fails.

   If the client is building the significant parts of an exchange for an
   HTTP Request/Response Exchange ([RFC7540], section 8.1), the "input
   request" is the request the client sent.  If the client is doing so




Yasskin                   Expires May 25, 2018                 [Page 13]

Internet-Draft        Origin-signed HTTP Responses         November 2017


   for a Server Push ([RFC7540], section 8.2), the input request is the
   request represented in the PUSH_PROMISE and its CONTINUATIONs.

   The significant parts of the exhange are the "application/http2" CBOR
   item (Section 5.4) with the following content:

   1.  The text string "request".

   2.  The array consisting of the appended items from, for each element
       "name" of the "Signed-Request-Headers" header field value,

       1.  Append "name" as a byte string.

       2.  If there is a header field named "name" in the input
           request's header fields, append that header field's value, as
           a byte string.

       3.  Otherwise, computing the significant parts fails.

   3.  The text string "response".

   4.  The array consisting of the appended items from, for each element
       "name" of the "Signed-Response-Headers" header field value,

       1.  Append "name" as a byte string.

       2.  If there is a header field named "name" in the response's
           header fields, append that header field's value, as a byte
           string.

       3.  Otherwise, computing the significant parts fails.

   5.  The text string "payload".

   6.  The byte string containing the response's payload body
       ([RFC7230], section 3.3).  Note that the payload body is the
       message body with any transfer encodings removed.

5.6.  Signature validity

   The client MUST use the following algorithm to determine whether each
   "Signature" header field (Section 5.2) is valid or invalid.

   1.   Let "exchange" be the significant parts (Section 5.5) of the
        "Signature" header's exchange.  If "exchange" is a failure, then
        return "invalid".





Yasskin                   Expires May 25, 2018                 [Page 14]

Internet-Draft        Origin-signed HTTP Responses         November 2017


   2.   Let "authority" be the ":authority" request header from
        "exchange".

   3.   If an error is thrown while parsing the "Signature" header as
        the dictionary described in Section 5.2
        ([I-D.nottingham-structured-headers], section 4.7.1), return
        "invalid".

   4.   Let:

        *  "certUrl" be the header's "certUrl" member

        *  "certSha256" be the header's "certSha256" member

        *  "date" be the header's "date" member, interpreted as a Unix
           time

        *  "expires" be the header's "expires" member, interpreted as a
           Unix time

        *  "signature" be the header's "sig" member

   5.   Let "certificate-chain" be the result of fetching ([FETCH])
        "certUrl" and parsing it as a TLS 1.3 Certificate message
        ([I-D.ietf-tls-tls13], section 4.4.2) containing X.509v3
        certificates.  The fetch can be fulfilled from a cache using
        normal HTTP semantics [RFC7234].  If this fetch or parse fails,
        return "invalid".

   6.   Let "main-certificate" be the first certificate in "certificate-
        chain".

   7.   Validate "main-certificate".  If any of these substeps fails and
        the "certUrl" was fetched from a cache, the client MAY
        invalidate that cache entry and restart this algorithm.
        Otherwise, a failure in a substep means to return "invalid".

        1.  Validate that the SHA-256 hash of "main-certificate"'s
            "cert_data" is equal to "certSha256".  See the open
            questions (Section 5.6.1, Paragraph 1).

        2.  Use "certificate-chain" to validate that "main-certificate"
            is trusted as "authority"'s server certificate ([RFC5280]
            and other undocumented conventions).  Let "path" be the path
            that was used from the "main-certificate" to a trusted root,
            including the "main-certificate" but excluding the root.





Yasskin                   Expires May 25, 2018                 [Page 15]

Internet-Draft        Origin-signed HTTP Responses         November 2017


        3.  Validate that all certificates in "path" include
            "status_request" extensions with valid OCSP responses.
            ([RFC6960])

        4.  Validate that all certificates in "path" include
            "signed_certificate_timestamp" extensions containing valid
            SCTs from trusted logs.  ([RFC6962])

   8.   The client MUST define a partial function from public key types
        to signing algorithms, and this function must at the minimum
        include the following mappings:

        RSA, 2048 bits:  rsa_pss_sha256 as defined in Section 4.2.3 of
           [I-D.ietf-tls-tls13].

        EC, with the secp256r1 curve:  ecdsa_secp256r1_sha256 as defined
           in Section 4.2.3 of [I-D.ietf-tls-tls13].

        EC, with the secp384r1 curve:  ecdsa_secp384r1_sha384 as defined
           in Section 4.2.3 of [I-D.ietf-tls-tls13].

        Let "signing-alg" be the result of applying this function to
        type of "main-certificate"'s public key.  If the function is
        undefined on this input, return "invalid".

   9.   If "expires" is more than 7 days (604800 seconds) after "date",
        return "invalid".

   10.  If the current time is before "date" or after "expires", return
        "invalid".

   11.  Let "message" be the concatenation of the following byte
        strings.  This matches the [I-D.ietf-tls-tls13] format to avoid
        cross-protocol attacks when TLS certificates are used to sign
        manifests.

        1.  A string that consists of octet 32 (0x20) repeated 64 times.

        2.  A context string: the ASCII encoding of "HTTP Exchange".

        3.  A single 0 byte which serves as a separator.

        4.  The bytes of the canonical CBOR encoding of a CBOR array
            consisting of:

            1.  The text string "certSha256".

            2.  The byte string "certSha256".



Yasskin                   Expires May 25, 2018                 [Page 16]

Internet-Draft        Origin-signed HTTP Responses         November 2017


            3.  The text string "date".

            4.  The integer value of "date".

            5.  The text string "expires".

            6.  The integer value of "expires".

            7.  The text string "exchange".

            8.  The CBOR item "exchange".  See the open questions
                (Section 5.6.1, Paragraph 2).

   12.  If "signature" is "message"'s signature by "main-certificate"'s
        public key using "signing-alg", return "valid".  Otherwise,
        return "invalid".

5.6.1.  Open Questions

   TLS 1.3 signs the entire certificate chain, but doing that here would
   preclude updating the OCSP signatures without replacing all
   "Signature" header fields at the same time.  What attack do I allow
   by hashing only the end-entity certificate?

   Including the entire exchange in the signed data forces a client to
   download the whole thing before trusting any of it.
   [I-D.thomson-http-mice] is designed to let us check the validity of
   just the "MI" header up front and then incrementally check blocks of
   the payload as they arrive.  What's the best way to integrate that?
   Maybe make the Section 5.5 omit the actual payload when there's an
   "MI" header with a matching "Content-Encoding" and warn clients to
   enforce the "MI" header when using the body?

5.7.  Updating signature validity

   Both OCSP responses and "Signature" header fields are designed to
   expire a short time after they're signed, so that revoked
   certificates and signed exchanges with known vulnerabilities are
   distrusted promptly.

   This specification provides no way to update OCSP responses by
   themselves.  Instead, clients need to re-fetch the "certUrl"
   (Paragraph 7) to get a chain including newer OCSPs.

   The "validityUrl" member (Paragraph 3) of the "Signature" header
   provides a way to fetch new signatures or learn where to fetch a
   complete updated package.




Yasskin                   Expires May 25, 2018                 [Page 17]

Internet-Draft        Origin-signed HTTP Responses         November 2017


   Each version of a signed exchange SHOULD have its own validity URLs,
   since each version needs different signatures and becomes obsolete at
   different times.

   The resource at a "validityUrl" is "validity data", a CBOR map
   matching the following CDDL ([I-D.ietf-cbor-cddl]):

   validity = {
     ? signatures: [ + bytes ]
     ? update: {
       url: text,
       ? size: uint,
     }
   ]

   The elements of the "signatures" array are header field values meant
   to replace the "Signature" header fields pointing to this validity
   data.  If the signed exchange contains a bug severe enough that
   clients need to stop using the content, the "signatures" array MUST
   NOT be present.

   The "update" map gives a location to update the entire signed
   exchange and an estimate of the size of the resource at that URL.  If
   the signed exchange is currently the most recent version, the
   "update" SHOULD NOT be present.

   If both the "signatures" and "update" fields are present, clients can
   use the estimated size to decide whether to update the whole resource
   or just its signatures.

5.7.1.  Examples

   For example, if a signed exchange has the following "Signature"
   header fields:

















Yasskin                   Expires May 25, 2018                 [Page 18]

Internet-Draft        Origin-signed HTTP Responses         November 2017


Signature: validityUrl="https://example.com/resource.validity",
  certUrl="https://example.com/certs",
  certSha256=*W7uB969dFW3Mb5ZefPS9Tq5ZbH5iSmOILpjv2qEArmI,
  date=1511128380, expires=1511560380,
  sig=*MEUCIQDXlI2gN3RNBlgFiuRNFpZXcDIaUpX6HIEwcZEc0cZYLAIga9DsVOMM+g5YpwEBdGW3sS+bvnmAJJiSMwhuBdqp5UY
Signature: validityUrl="https://example.com/resource.validity",
  certUrl="https://example.com/certs",
  certSha256=*kQAA8u33cZRTy7RHMO4+dv57baZL48SYA2PqmYvPPbg,
  date=1511301183, expires=1511905983,
  sig=*MEQCIGjZRqTRf9iKNkGFyzRMTFgwf/BrY2ZNIP/dykhUV0aYAiBTXg+8wujoT4n/W+cNgb7pGqQvIUGYZ8u8HZJ5YH26Qg
Signature: validityUrl="https://thirdparty.example.com/resource.validity",
  certUrl="https://thirdparty.example.com/certs",
  certSha256=*UeOwUPkvxlGRTyvHcsMUN0A2oNsZbU8EUvg8A9ZAnNc,
  date=1511301183, expires=1511905983,
  sig=*MEYCIQCNxJzn6Rh2fNxsobktir8TkiaJYQFhWTuWI1i4PewQaQIhAMs2TVjc4rTshDtXbgQEOwgj2mRXALhfXPztXgPupii+

   https://example.com/resource.validity might contain:

{
  "signatures": [
    'validityUrl="https://example.com/resource.validity", '
    'certUrl="https://example.com/certs", '
    'certSha256=*W7uB969dFW3Mb5ZefPS9Tq5ZbH5iSmOILpjv2qEArmI, '
    'date=1511467200, expires=1511985600, '
    'sig=*MEQCIC/I9Q+7BZFP6cSDsWx43pBAL0ujTbON/+7RwKVk+ba5AiB3FSFLZqpzmDJ0NumNwN04pqgJZE99fcK86UjkPbj4jw'
  ],
  "update": {
    "url": "https://example.com/resource",
    "size": 5557452
  }
}

   This indicates that the first two of the original "Signature" header
   fields (the ones with a validityUrl of "https://example.com/
   resource.validity") can be replaced with a single new header field.
   The "Signature" header fields of the updated signed exchange would
   be:

Signature: validityUrl="https://example.com/resource.validity",
  certUrl="https://example.com/certs",
  certSha256=*W7uB969dFW3Mb5ZefPS9Tq5ZbH5iSmOILpjv2qEArmI,
  date=1511467200, expires=1511985600,
  sig=*MEQCIC/I9Q+7BZFP6cSDsWx43pBAL0ujTbON/+7RwKVk+ba5AiB3FSFLZqpzmDJ0NumNwN04pqgJZE99fcK86UjkPbj4jw
Signature: validityUrl="https://thirdparty.example.com/resource.validity",
  certUrl="https://thirdparty.example.com/certs",
  certSha256=*UeOwUPkvxlGRTyvHcsMUN0A2oNsZbU8EUvg8A9ZAnNc,
  date=1511301183, expires=1511905983,
  sig=*MEYCIQCNxJzn6Rh2fNxsobktir8TkiaJYQFhWTuWI1i4PewQaQIhAMs2TVjc4rTshDtXbgQEOwgj2mRXALhfXPztXgPupii+



Yasskin                   Expires May 25, 2018                 [Page 19]

Internet-Draft        Origin-signed HTTP Responses         November 2017


   https://example.com/resource.validity could also expand the set of
   "Signature" header fields if its "signatures" array contained more
   than 2 elements.

6.  Security considerations

   Authors MUST NOT include confidential information in a signed
   response that an untrusted intermediate could forward, since the
   response is only signed and not encrypted.  Intermediates can read
   the content.

   Relaxing the requirement to consult DNS when determining authority
   for an origin means that an attacker who possesses a valid
   certificate no longer needs to be on-path to redirect traffic to
   them; instead of modifying DNS, they need only convince the user to
   visit another Web site in order to serve responses signed as the
   target.  This consideration and mitigations for it are shared by
   [I-D.ietf-httpbis-origin-frame].

   Signing a bad response can affect more users than simply serving a
   bad response, since a served response will only affect users who make
   a request while the bad version is live, while an attacker can
   forward a signed response until its signature expires.  Authors
   should consider shorter signature expiration times than they use for
   cache expiration times.

   An attacker with temporary access to a signing oracle can sign "still
   valid" assertions with arbitrary timestamps and expiration times.  As
   a result, when a signing oracle is removed, the keys it provided
   access to SHOULD be revoked so that, even if the attacker used them
   to sign future-dated package validity assertions, the key's OCSP
   assertions will expire, causing the package as a whole to become
   untrusted.

7.  Privacy considerations

   Normally, when a client fetches "https://o1.com/resource.js",
   "o1.com" learns that the client is interested in the resource.  If
   "o1.com" signs "resource.js", "o2.com" serves it as "https://o2.com/
   o1resource.js", and the client fetches it from there, then "o2.com"
   learns that the client is interested, and if the client executes the
   Javascript, that could also report the client's interest back to
   "o1.com".

   Often, "o2.com" already knew about the client's interest, because
   it's the entity that directed the client to "o1resource.js", but
   there may be cases where this leaks extra information.




Yasskin                   Expires May 25, 2018                 [Page 20]

Internet-Draft        Origin-signed HTTP Responses         November 2017


   For non-executable resource types, a signed response can improve the
   privacy situation by hiding the client's interest from the original
   author.

8.  IANA considerations

   This document has no actions for IANA.

9.  References

9.1.  Normative References

   [FETCH]    WHATWG, "Fetch", November 2017,
              <https://fetch.spec.whatwg.org/>.

   [I-D.ietf-cbor-cddl]
              Birkholz, H., Vigano, C., and C. Bormann, "Concise data
              definition language (CDDL): a notational convention to
              express CBOR data structures", draft-ietf-cbor-cddl-00
              (work in progress), July 2017.

   [I-D.ietf-tls-tls13]
              Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", draft-ietf-tls-tls13-21 (work in progress),
              July 2017.

   [I-D.nottingham-structured-headers]
              Nottingham, M. and P. Kamp, "Structured Headers for HTTP",
              draft-nottingham-structured-headers-00 (work in progress),
              October 2017.

   [POSIX]    IEEE and The Open Group, "The Open Group Base
              Specifications Issue 7", name IEEE, value 1003.1-2008,
              2016 Edition, 2016,
              <http://pubs.opengroup.org/onlinepubs/9699919799/
              basedefs/>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 5280, DOI 10.17487/RFC5280, May 2008,
              <https://www.rfc-editor.org/info/rfc5280>.




Yasskin                   Expires May 25, 2018                 [Page 21]

Internet-Draft        Origin-signed HTTP Responses         November 2017


   [RFC6960]  Santesson, S., Myers, M., Ankney, R., Malpani, A.,
              Galperin, S., and C. Adams, "X.509 Internet Public Key
              Infrastructure Online Certificate Status Protocol - OCSP",
              RFC 6960, DOI 10.17487/RFC6960, June 2013,
              <https://www.rfc-editor.org/info/rfc6960>.

   [RFC6962]  Laurie, B., Langley, A., and E. Kasper, "Certificate
              Transparency", RFC 6962, DOI 10.17487/RFC6962, June 2013,
              <https://www.rfc-editor.org/info/rfc6962>.

   [RFC7049]  Bormann, C. and P. Hoffman, "Concise Binary Object
              Representation (CBOR)", RFC 7049, DOI 10.17487/RFC7049,
              October 2013, <https://www.rfc-editor.org/info/rfc7049>.

   [RFC7230]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing",
              RFC 7230, DOI 10.17487/RFC7230, June 2014,
              <https://www.rfc-editor.org/info/rfc7230>.

   [RFC7231]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Semantics and Content", RFC 7231,
              DOI 10.17487/RFC7231, June 2014,
              <https://www.rfc-editor.org/info/rfc7231>.

   [RFC7234]  Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "Hypertext Transfer Protocol (HTTP/1.1): Caching",
              RFC 7234, DOI 10.17487/RFC7234, June 2014,
              <https://www.rfc-editor.org/info/rfc7234>.

   [RFC7540]  Belshe, M., Peon, R., and M. Thomson, Ed., "Hypertext
              Transfer Protocol Version 2 (HTTP/2)", RFC 7540,
              DOI 10.17487/RFC7540, May 2015,
              <https://www.rfc-editor.org/info/rfc7540>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

9.2.  Informative References

   [I-D.burke-content-signature]
              Burke, B., "HTTP Header for digital signatures", draft-
              burke-content-signature-00 (work in progress), March 2011.

   [I-D.cavage-http-signatures]
              Cavage, M. and M. Sporny, "Signing HTTP Messages", draft-
              cavage-http-signatures-09 (work in progress), November
              2017.



Yasskin                   Expires May 25, 2018                 [Page 22]

Internet-Draft        Origin-signed HTTP Responses         November 2017


   [I-D.ietf-httpbis-origin-frame]
              Nottingham, M. and E. Nygren, "The ORIGIN HTTP/2 Frame",
              draft-ietf-httpbis-origin-frame-04 (work in progress),
              August 2017.

   [I-D.thomson-http-content-signature]
              Thomson, M., "Content-Signature Header Field for HTTP",
              draft-thomson-http-content-signature-00 (work in
              progress), July 2015.

   [I-D.thomson-http-mice]
              Thomson, M., "Merkle Integrity Content Encoding", draft-
              thomson-http-mice-02 (work in progress), October 2016.

   [I-D.yasskin-dispatch-web-packaging]
              Yasskin, J., "Web Packaging", draft-yasskin-dispatch-web-
              packaging-00 (work in progress), June 2017.

   [RFC2437]  Kaliski, B. and J. Staddon, "PKCS #1: RSA Cryptography
              Specifications Version 2.0", RFC 2437,
              DOI 10.17487/RFC2437, October 1998,
              <https://www.rfc-editor.org/info/rfc2437>.

   [RFC6066]  Eastlake 3rd, D., "Transport Layer Security (TLS)
              Extensions: Extension Definitions", RFC 6066,
              DOI 10.17487/RFC6066, January 2011,
              <https://www.rfc-editor.org/info/rfc6066>.

   [RFC6454]  Barth, A., "The Web Origin Concept", RFC 6454,
              DOI 10.17487/RFC6454, December 2011,
              <https://www.rfc-editor.org/info/rfc6454>.

   [RFC7232]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Conditional Requests", RFC 7232,
              DOI 10.17487/RFC7232, June 2014,
              <https://www.rfc-editor.org/info/rfc7232>.

   [RFC7541]  Peon, R. and H. Ruellan, "HPACK: Header Compression for
              HTTP/2", RFC 7541, DOI 10.17487/RFC7541, May 2015,
              <https://www.rfc-editor.org/info/rfc7541>.

   [SRI]      Akhawe, D., Braun, F., Marier, F., and J. Weinberger,
              "Subresource Integrity", World Wide Web Consortium
              Recommendation REC-SRI-20160623, June 2016,
              <http://www.w3.org/TR/2016/REC-SRI-20160623>.






Yasskin                   Expires May 25, 2018                 [Page 23]

Internet-Draft        Origin-signed HTTP Responses         November 2017


9.3.  URIs

   [1] https://lists.w3.org/Archives/Public/ietf-http-wg/

   [2] https://github.com/WICG/webpackage

   [3] https://datatracker.ietf.org/doc/minutes-99-dispatch/

   [4] http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/
       V1_chap04.html#tag_04_16

   [5] https://github.com/mikewest/signature-based-sri

   [6] https://github.com/mikewest/signature-based-sri/issues/5

   [7] https://github.com/WICG/webpackage

   [8] https://tools.ietf.org/html/rfc7540#section-8.2

   [9] https://www.imperialviolet.org/2012/02/05/crlsets.html

   [10] https://tlswg.github.io/tls13-spec/draft-ietf-tls-
        tls13.html#ocsp-and-sct

   [11] https://tools.ietf.org/html/rfc7540#section-4.2

   [12] https://url.spec.whatwg.org/#valid-url-string

   [13] https://url.spec.whatwg.org/#valid-url-string

   [14] https://example.com/

Appendix A.  Acknowledgements

   Thanks to Ilari Liusvaara for comments that improved this draft.

Author's Address

   Jeffrey Yasskin
   Google

   Email: jyasskin@chromium.org









Yasskin                   Expires May 25, 2018                 [Page 24]
